<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Android," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="一文详尽 Android 通信：四大组件之间 &amp;amp; 进程间 &amp;amp; 线程间 &amp;amp; 多个App间  
本文大纲看完本文能收获什么？按目录索引，你可以学习到：

组件间的通信，Activity，fragment，Service， Provider，Receiver

进程间的通信，AIDL

线程间的通信，Handler，AnsycTask，IntentService

多个App间的">
<meta property="og:type" content="article">
<meta property="og:title" content="详解 Android 通信">
<meta property="og:url" content="http://ocnyang.com/2017/02/13/AndroidComm/index.html">
<meta property="og:site_name" content="杨欧神/OCN.Yang">
<meta property="og:description" content="一文详尽 Android 通信：四大组件之间 &amp;amp; 进程间 &amp;amp; 线程间 &amp;amp; 多个App间  
本文大纲看完本文能收获什么？按目录索引，你可以学习到：

组件间的通信，Activity，fragment，Service， Provider，Receiver

进程间的通信，AIDL

线程间的通信，Handler，AnsycTask，IntentService

多个App间的">
<meta property="og:image" content="http://obbu6r1mi.bkt.clouddn.com/ocnyang/android_comm/androidcomm.jpg">
<meta property="og:image" content="http://obbu6r1mi.bkt.clouddn.com/ocnyang/android_comm/%E9%80%9A%E4%BF%A1fragment.jpg">
<meta property="og:image" content="http://obbu6r1mi.bkt.clouddn.com/ocnyang/android_comm/Fragment%E9%80%9A%E4%BF%A1_gif.gif">
<meta property="og:image" content="http://obbu6r1mi.bkt.clouddn.com/ocnyang/android_comm/intent-chooser.png">
<meta property="og:image" content="http://obbu6r1mi.bkt.clouddn.com/ocnyang/android_comm/EventBus-Publish-Subscribe.png">
<meta property="og:updated_time" content="2017-02-13T14:36:19.989Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="详解 Android 通信">
<meta name="twitter:description" content="一文详尽 Android 通信：四大组件之间 &amp;amp; 进程间 &amp;amp; 线程间 &amp;amp; 多个App间  
本文大纲看完本文能收获什么？按目录索引，你可以学习到：

组件间的通信，Activity，fragment，Service， Provider，Receiver

进程间的通信，AIDL

线程间的通信，Handler，AnsycTask，IntentService

多个App间的">
<meta name="twitter:image" content="http://obbu6r1mi.bkt.clouddn.com/ocnyang/android_comm/androidcomm.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://ocnyang.com/2017/02/13/AndroidComm/"/>





  <title> 详解 Android 通信 | 杨欧神/OCN.Yang </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?923326cdfba9134256dbbf5887c8ce38";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>










  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">杨欧神/OCN.Yang</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">我问佛：如何让心不再感到孤单？<br>佛曰：每一颗心生来就是孤单而残缺的，多数带着这种残缺度过一生，只因与能使它圆满的另一半相遇时，不是疏忽错过，就是已失去了拥有它的资格</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-circle-o-notch"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-list"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-hourglass-start"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-efall">
          <a href="/categories/还相信爱情/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-key"></i> <br />
            
            E.Fall
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user-secret"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://ocnyang.com/2017/02/13/AndroidComm/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="OCN.Yang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/ocnyang.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="杨欧神/OCN.Yang">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                详解 Android 通信
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-02-13T22:03:15+08:00">
                2017-02-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android教程系列/" itemprop="url" rel="index">
                    <span itemprop="name">Android教程系列</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/02/13/AndroidComm/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2017/02/13/AndroidComm/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2017/02/13/AndroidComm/" class="leancloud_visitors" data-flag-title="详解 Android 通信">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="一文详尽-Android-通信：四大组件之间-amp-进程间-amp-线程间-amp-多个App间"><a href="#一文详尽-Android-通信：四大组件之间-amp-进程间-amp-线程间-amp-多个App间" class="headerlink" title="一文详尽 Android 通信：四大组件之间 &amp; 进程间 &amp; 线程间 &amp; 多个App间"></a>一文详尽 Android 通信：四大组件之间 &amp; 进程间 &amp; 线程间 &amp; 多个App间</h1><p><img src="http://obbu6r1mi.bkt.clouddn.com/ocnyang/android_comm/androidcomm.jpg" alt="">  </p>
<h2 id="本文大纲"><a href="#本文大纲" class="headerlink" title="本文大纲"></a>本文大纲</h2><p><strong>看完本文能收获什么？按目录索引，你可以学习到：</strong></p>
<ol>
<li><p>组件间的通信，Activity，fragment，Service， Provider，Receiver</p>
</li>
<li><p>进程间的通信，AIDL</p>
</li>
<li><p>线程间的通信，Handler，AnsycTask，IntentService</p>
</li>
<li><p>多个App间的通信</p>
</li>
<li><p>使用大型开源框架完成组件通信，EventBus，otto</p>
</li>
</ol>
<p><strong>建议阅读本文时遵循以下学习思路</strong></p>
<ol>
<li><p>研究对象：Activity，fragment等组件</p>
</li>
<li><p>信息存在形式：Intent，Bundle，静态变量，全局变量，还是点击事件，触摸事件的回调监听，或者文件形式（Sharepreference，SQLite，File , NetStream） ，本质就是信息源</p>
</li>
<li><p>信息传递的形式：网路，回调监听，线程，Intent，全局Application</p>
</li>
<li><p>相同形式的思路，不会出现第二次，请读者举一反三</p>
</li>
<li><p>最后强调研究对象是单一的</p>
</li>
</ol>
<h2 id="Activity通信"><a href="#Activity通信" class="headerlink" title="Activity通信"></a>Activity通信</h2><h3 id="Activity-和-Activity"><a href="#Activity-和-Activity" class="headerlink" title="Activity 和 Activity"></a>Activity 和 Activity</h3><p><strong>1. 常规方式：Intent Bundle</strong></p>
<p>通过Intent 启动另一个Activity时，有两种重载方式：</p>
<pre><code>startActivity(new Intent(),new Bundle());
startActivityForResult(new Intent(),FLAG,new Bundle());
</code></pre><p>从参数列表就可以总结出来，有Intent，和Bundle,可以传递8种基本数据类型和可序列化的数据类型，比如字符串和字节数组。提到可序列化，就引发 Intent和Bundle 的局限性了:</p>
<ol>
<li>Intent Bundle 无法传递“不可序列化”的数据，比如Bitmap，InputStream，解决办法有很多种，最简单的就是将“不可序列化”的对象，转换成字节数组，这里因为主要是讲解通信，所以不展开讲了。  </li>
<li>Intent Bundle 能传递的数据大小在40K以内 。  </li>
</ol>
<blockquote>
<p>很多人不理解为什么把Intent和Bundle放在一起谈，因为Intent 底层存储信息的原理也是通过Bundle存储！</p>
</blockquote>
<p><strong>2. 公有静态变量</strong></p>
<p>比如 <code>public static String flag=“杨欧神”；</code></p>
<p>使用方式 比如在其他Activity当中 <code>FirstActivity.flag=“OCNYang”;</code> 修改静态变量的值</p>
<p><strong>3. 基于物理形式：</strong></p>
<p>比如 <strong><code>File，SQLite，Sharepreference</code></strong> 物理形式</p>
<p><strong>4. 全局变量：</strong></p>
<p>比如Application：Application是与Activity，Service齐名的组件，非常强大，它的特点是全局组件共用，单例形式存在，在其他组件中，我们只需要 <code>Context.getApplication（）</code> 获得该对象的引用即可</p>
<h3 id="Activity-和-Fragment，Service，BrodcastReceiver"><a href="#Activity-和-Fragment，Service，BrodcastReceiver" class="headerlink" title="Activity 和 Fragment，Service，BrodcastReceiver"></a>Activity 和 Fragment，Service，BrodcastReceiver</h3><p>首先都遵循，如何启动它们，就如何传递信息的原则：</p>
<p><strong>1. Activity与Fragment</strong></p>
<p><code>1. 通过构造函数传递</code>  <code>2. 获取Fragment的实例对象</code>   </p>
<pre><code>//CustFragment 是自定义的fragment，参数列表也可以自己定义咯，
getSupportFragmentManager().beginTransaction()
             .add(new CustFragment(自定义的的参数列表),new String(&quot;参数&quot;))

//------------------method two-----------------------
getSupportFragmentManager().findFragmentById(R.id.headlines_fragment);
//------------------method three----------------------
getSupportFragmentManager().findFragmentByTag(&quot;HeadLines&quot;);
</code></pre><blockquote>
<p>聪明的读者可能会问Fragment如何与Activity通信类似的问题，这是个好问题，请注意我们的研究的原则是单一目标原则，在这节我研究的是Activity，你的疑惑在后面都会一一解答  </p>
</blockquote>
<p><strong>2. Activity与Service</strong></p>
<p>Activity启动Service的两种方式：</p>
<pre><code>//CustomService 是自定义Service，完成一些后台操作

startService(new Intent(FirstActivity.this，CustomService.class));

bindService(new Intent(FirstActivity.this，CustomService.class)), new ServiceConnection() {
          @Override
          public void onServiceConnected(ComponentName name, IBinder service) {
              //当前启动的service 一些数据就会回调回这里，我们在Activity中操作这些数据即可
              get
          }

          @Override
          public void onServiceDisconnected(ComponentName name) {

          }
      },flags);
</code></pre><p>从启动方式就可以看出，通过Bundle对象的形式存储，通过Intent传输，来完成Activity向Service传递数据的操作</p>
<p><strong>3. Activity与BroadcastReceiver</strong></p>
<p>启动广播的形式也有两种:</p>
<pre><code>//method one ！！！-----------------------------------------------
registerReceiver(new BroadcastReceiver() {
          @Override
          public void onReceive(Context context, Intent intent) {

          }
      },new IntentFilter(),&quot;&quot;,new Handler());

//method two ！！！-----------------------------------------------
registerReceiver(new BroadcastReceiver() {
          @Override
          public void onReceive(Context context, Intent intent) {

          }
      },new IntentFilter());  
</code></pre><blockquote>
<p>关于method one 的第三个参数Handler很多人会很费解<br>参照registerReceiver中源码关于该Handler参数的解释：<br><code>Handler identifying the thread that will receive the Intent. If null, the main thread of the process will be used.</code><br>定义了一个用于接收Intent的子线程，如果不填或者默认为null，那么就会在主线程中完成接收Intent的操作  </p>
</blockquote>
<p>很明显，Activity与BroadcastReceiver通信时，用的也是Intent传递，Bundle存储。</p>
<p><strong>4. 通讯时的同步问题</strong></p>
<blockquote>
<p>这里的同步通讯问题，为下文Fragment通讯作铺垫，不是这个问题不重要，不值得引起你注意，只是我想把问题放在它最应该出现的位置。</p>
</blockquote>
<p>以上只是基础的传递数据的形式，大部分都是静态的，现在有一种需求，用户操作Activity，发出了某些指令，比如按下，滑动，触摸等操作，如何完成这些信息传递呢？这就要求同步了。</p>
<p>同步传递消息也很简单，就是调用系统写好的回调接口</p>
<p>首先我们要知道，用户 点击，触摸 这些行为 也属于 通信的范畴—点击和触摸属于 信息源；<br>比如用户行为进行点击，那就实现 ：</p>
<pre><code>new Button(mCotext).setOnClickListener(new View.OnClickListener() {
       @Override
       public void onClick(View v) {
           new ImageView(mCotext).invalidate();
       }
   });
</code></pre><p>通过此招提示指定的ImageView：嘿！老兄，你该刷新了</p>
<p>又或者 当用户 进行触摸操作，我们需要实现放大缩小平移指定的区域：</p>
<pre><code>new RelativeLayout(mCotext).setOnTouchListener(new View.OnTouchListener() {
          @Override
          public boolean onTouch(View v, MotionEvent event) {
              //缩放
              v.setScaleX(1f);
              v.setScaleY(1f);
              //平移
              v.setTranslationX(1f);
              v.setTranslationY(1f);
              v.setTranslationY(1f);
              //旋转
              v.setRotation(2f);
              v.setRotationX(2f);
              v.setRotationY(2f);

              v.invalidate();
              return true;
          }
      });
</code></pre><p>嘿，你看，当用户进行触摸操作，我们可以通过回调onTouchListenter来完成“触摸”这一操作</p>
<blockquote>
<p>关于View重绘机制以及优化刷新UI的细节，不属于本文讨论范围。</p>
</blockquote>
<h2 id="Fragment"><a href="#Fragment" class="headerlink" title="Fragment"></a>Fragment</h2><h3 id="1-Fragment-与Activity通信"><a href="#1-Fragment-与Activity通信" class="headerlink" title="1. Fragment 与Activity通信"></a>1. Fragment 与Activity通信</h3><p>通过实例对象传递</p>
<p>同样的，在 Fragment 中 <code>getActivity()</code> 可以获取到它相关联的 Activity 实例，就可以轻松获取并且修改 Activity 的数据。</p>
<h3 id="2-Fragment-与-多个Fragment通信"><a href="#2-Fragment-与-多个Fragment通信" class="headerlink" title="2. Fragment 与 多个Fragment通信"></a>2. Fragment 与 多个Fragment通信</h3><p>首先，两个Fragment之间不可能直接通信（非正规因素除外），Google官方提出的解决办法是 通过相关联的Activity来完成两个Fragment的通信</p>
<p>只需要记住三步：</p>
<p><strong>1. 定义一个接口：</strong></p>
<p>在让Fragment关联Activity之前，可以在Fragment中定义一个接口，然后让宿主Activity来实现这个接口。接着，在Fragment中捕获这个接口，并且在onAttach()中 捕获Activity实例</p>
<pre><code>//只需关注接口是如何定义的，以及onAttack中的实现
public class HeadlinesFragment extends ListFragment {
    //定义的接口引用
    OnHeadlineSelectedListener mCallback;

    // 自定义回调接口，宿主Activity必须要实现它
    public interface OnHeadlineSelectedListener {
        public void onArticleSelected(int position);
    }

    @Override
    public void onAttach(Activity activity) {
        super.onAttach(activity);

        // 在这里只是为了确保Activity实现了我们定义的接口，如果没有实现，则抛出异常
        try {
            mCallback = (OnHeadlineSelectedListener) activity;
        } catch (ClassCastException e) {
            throw new ClassCastException(activity.toString()
                    + &quot; must implement OnHeadlineSelectedListener&quot;);
        }
    }

    ...
}
</code></pre><p>一旦 Activity 通过 <code>OnHeadlineSelectedListener</code> 的实例 mCallBack 回调  <code>onArticleSelected（）</code> ，Fragment 就可以传递信息给 Activity 了</p>
<p>例如 下面是 ListFragment 的一个回调方法，当用户点击了 list 中的 item，这个 Fragment 就会通过回调接口向宿主 Activity 传递事件</p>
<pre><code>@Override
   public void onListItemClick(ListView l, View v, int position, long id) {
       // 向Activity传递事件信息
       mCallback.onArticleSelected(position);
   }
</code></pre><p><strong>2. 在宿主Activity实现这个接口</strong></p>
<p>怎么实现？很简单，参考下面代码：</p>
<pre><code>public static class MainActivity extends Activity
        implements HeadlinesFragment.OnHeadlineSelectedListener{
    ...

    public void onArticleSelected(int position) {
        // 用户从从 HeadlinesFragment选中了一个标题
        //响应用户的操作，做一些业务逻辑
    }
}
</code></pre><p><strong>3. 向其他Fragment传递信息 （完成通信）</strong></p>
<p>宿主Activity可以通过findFragmentById()向指定的Fragment传递信息，宿主Activity可以直接获取Fragment实例，回调Fragment的公有方法</p>
<p>例如：</p>
<p>宿主Activity 包含了一个Listfragment用来展示条目信息，当每个条目被点击的时候，我们希望ListFragment向另外一个DetailsFragment传递一个信息用来 展示不同的细节</p>
<pre><code>public static class MainActivity extends Activity
        implements HeadlinesFragment.OnHeadlineSelectedListener{
    ...

     public void onArticleSelected(int position) {
        // 用户在 HeadlinesFragment中选中了一个item

        //在activity中添加新的fragment
        ArticleFragment articleFrag = (ArticleFragment)
                getSupportFragmentManager().findFragmentById(R.id.article_fragment);

        if (articleFrag != null) {
            // If article 对象 可以复用, 我们就不需要创建两遍了

            // 回调articleFrag 更新
            articleFrag.updateArticleView(position);

        } else {
            // 创建 Fragment 并为其添加一个参数，用来指定应显示的文章
            ArticleFragment newFragment = new ArticleFragment();
            Bundle args = new Bundle();
            args.putInt(ArticleFragment.ARG_POSITION, position);
            newFragment.setArguments(args);

            FragmentTransaction transaction = getSupportFragmentManager().beginTransaction();

            // 将 fragment_container View 时中的内容替换为此 Fragment ，
            // 然后将该事务添加到返回堆栈，以便用户可以向后回滚
            transaction.replace(R.id.fragment_container, newFragment);
            int setTransition=TRANSIT_FRAGMENT_OPEN;
            transaction.setTransition(setTransition);
            transaction.addToBackStack(null);

            // 执行事务
            transaction.commit();
        }
    }
}
</code></pre><p>下面我写了一个实例来供大家理解：</p>
<p>各个类的联系图：</p>
<p><img src="http://obbu6r1mi.bkt.clouddn.com/ocnyang/android_comm/%E9%80%9A%E4%BF%A1fragment.jpg" alt="">  </p>
<p>这里写图片描述</p>
<p>效果如下：</p>
<p><img src="http://obbu6r1mi.bkt.clouddn.com/ocnyang/android_comm/Fragment%E9%80%9A%E4%BF%A1_gif.gif" alt="">  </p>
<p>这里写图片描述</p>
<p><a href="http://download.csdn.net/detail/chivalrousman/9545616" target="_blank" rel="external">Fragment 通信 Demo 实例</a>  </p>
<h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><h3 id="Service-与-Activity-通信"><a href="#Service-与-Activity-通信" class="headerlink" title="Service 与 Activity 通信"></a>Service 与 Activity 通信</h3><p>主要是如何获得Service实例的问题<br>总结来说两步：</p>
<ol>
<li>在Service定义内部类，继承Binder，封装Service作为内部类的属性，并且在onBind方法中返回内部类的实例对象  </li>
<li><p>在Activity中实现ServiceConnection ，获取到Binder对象，再通过Binder获取Service<br>&gt;</p>
<p> public class LocalService extends Service {</p>
<pre><code>// 传递给客户端的Binder
private final IBinder mBinder = new LocalBinder();
//构造Random对象
private final Random mGenerator = new Random();

/**
 * 这个类提供给客户端  ，因为Service总是运行在同一个进程中的
 */
public class LocalBinder extends Binder {
    LocalService getService() {
        // 当客户端回调的时候，返回LoacalService实例
        return LocalService.this;
    }
}

@Override
public IBinder onBind(Intent intent) {
    return mBinder;
}

/**交给客户端回调的方法 */
public int getRandomNumber() {
  return mGenerator.nextInt(100);
}
</code></pre><p> }</p>
<p> public class BindingActivity extends Activity {</p>
<pre><code>LocalService mService;
boolean mBound = false;

@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.main);
}

@Override
protected void onStart() {
    super.onStart();
    // 绑定 LocalService
    Intent intent = new Intent(this, LocalService.class);
    bindService(intent, mConnection, Context.BIND_AUTO_CREATE);
}

@Override
protected void onStop() {
    super.onStop();
    // 解绑 service
    if (mBound) {
        unbindService(mConnection);
        mBound = false;
    }
}

/**button已经通过 android:onClick (attribute) 设置此方法响应用户click*/
public void onButtonClick(View v) {
    if (mBound) {
        // 回调 LocalService的方法.
        //因为在主线程中刷新UI，可能会造成线程阻塞，这里只是为了测试
        int num = mService.getRandomNumber();
        Toast.makeText(this, &quot;number: &quot; + num, Toast.LENGTH_SHORT).show();
    }
}

/**定义通过bindService 回调的Binder */
private ServiceConnection mConnection = new ServiceConnection() {

    @Override
    public void onServiceConnected(ComponentName className,
            IBinder service) {
       //先通过Binder获得Service的内部类 LoacalBinder
        LocalBinder binder = (LocalBinder) service;
         // 现在可以获得service对象了
        mService = binder.getService();
        mBound = true;
    }

    @Override
    public void onServiceDisconnected(ComponentName arg0) {
        mBound = false;
    }
};
</code></pre><p> }</p>
</li>
</ol>
<p>除了这种回调的方式外</p>
<p>还有一种方式 是在Service中 发送广播，</p>
<p>比如 在 Service 中 开启了一个子线程执行任务，就在子线程的 run() 方法中去 <code>sendBroadcast(intent);</code><br>数据用Intent封装，传递形式用广播</p>
<h2 id="AIDL-完成进程间通信"><a href="#AIDL-完成进程间通信" class="headerlink" title="AIDL 完成进程间通信"></a>AIDL 完成进程间通信</h2><p>关于进程和线程的细节改天详细说明，我们首先了解一下进程和线程的概念：</p>
<blockquote>
<p>当某个应用组件启动且该应用没有运行其他任何组件时，<a href="http://ocnyang.com">Android</a> 系统会使用单个执行线程为应用启动新的 Linux<br>进程。默认情况下，同一应用的所有组件在相同的进程和线程（称为“主”线程）中运行。<br>如果某个应用组件启动且该应用已存在进程（因为存在该应用的其他组件），则该组件会在此进程内启动并使用相同的执行线程。<br>但是，我们也可以安排应用中的其他组件在单独的进程中运行，并为任何进程创建额外的线程。  </p>
<p>各类组件元素的清单文件条目—：activity，servicer，eceiver 和 provider 均支持 android:process 属性，此属性可以指定该组件应在哪个进程运行。我们可以设置此属性，使每个组件均在各自的进程中运行，或者使一些组件共享一个进程，而其他组件则不共享。 此外，我们还可以设置 android:process，使不同应用的组件在相同的进程中运行  </p>
</blockquote>
<p>以及了解一下 进程间通信的概念</p>
<blockquote>
<p>Android 利用远程过程调用 (RPC) 提供了一种进程间通信 (IPC) 机制，通过这种机制，由 Activity<br>或其他应用组件调用的方法将（在其他进程中）远程执行，而所有结果将返回给调用方。这就要求把方法调用及其数据分解至操作系统可以识别的程度，并将其从本地进程和地址空间传输至远程进程和地址空间，然后在远程进程中重新组装并执行该调用。<br>然后，返回值将沿相反方向传输回来。 Android 提供了执行这些 IPC 事务所需的全部代码，因此我们只需集中精力定义和实现 RPC<br>编程接口即可。  </p>
<p>要执行 IPC，必须使用 bindService() 将应用绑定到服务上。</p>
</blockquote>
<p>具体实现 可以 <a href="http://blog.csdn.net/u013478336/article/details/43818185" target="_blank" rel="external">参考这个实例</a> 和文末给出的官方文档</p>
<h2 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h2><p>Handler 和AsyncTask都是用来完成子线程和主线程即UI线程通信的</p>
<p>都可以解决主线程 处理耗时操作，造成界面卡顿或者程序无响应ANR异常 这一类问题</p>
<p>Handler 是 一种机制【Handler+Message+Looper】，所有的数据通过Message携带，，所有的执行顺序按照队列的形式执行，Looper用来轮询判断消息队列，Handler用来接收和发送Message</p>
<p>AsyncTask 是一个单独的类，设计之初的目的只是为了 异步方式完成耗时操作的，顺便可以通知主线程刷新Ui，AsyncTask的内部机制则是维护了一个线程池，提升性能。</p>
<p>在这里提供另一种优雅的做法完成线程间的通信：</p>
<p>扩展 IntentService 类</p>
<p>由于大多数启动服务都不必同时处理多个请求（实际上，这种多线程情况可能很危险），因此使用 IntentService 类实现服务值得一试。<br>但如需同时处理多个启动请求，则更适合使用该基类Service。</p>
<p>IntentService 执行以下操作：</p>
<ul>
<li>创建默认的工作线程，用于在应用的主线程外执行传递给 onStartCommand() 的所有 Intent。</li>
<li>创建工作队列，用于将一个 Intent 逐一传递给 onHandleIntent() 实现，这样我们就永远不必担心多线程问题。</li>
<li>在处理完所有启动请求后停止服务，因此我们不必调用 stopSelf()。</li>
<li>提供 onBind() 的默认实现（返回 null）。</li>
<li>提供 onStartCommand() 的默认实现，可将 Intent 依次发送到工作队列和 onHandleIntent() 实现。<br>综上所述，您只需实现 onHandleIntent() 来完成客户端提供的工作即可。（不过，我们还需要为服务提供小型构造函数。）  </li>
</ul>
<p>以下是 IntentService 的实现示例：</p>
<pre><code>public class HelloIntentService extends IntentService {

  /**
   * 必须有构造函数 必须调用父 IntentService(String)带有name的构造函数来执行工作线程
   */
  public HelloIntentService() {
      super(&quot;HelloIntentService&quot;);
  }

  /**
   * IntentService 调用默认的工作线程启动服务
   * 当此方法结束，, IntentService 服务结束
   */
  @Override
  protected void onHandleIntent(Intent intent) {
      // 通常在这里会执行一些操作，比如下载文件
      //在这里只是sleep 5 s
      long endTime = System.currentTimeMillis() + 5*1000;
      while (System.currentTimeMillis() &amp;lt; endTime) {
          synchronized (this) {
              try {
                  wait(endTime - System.currentTimeMillis());
              } catch (Exception e) {
              }
          }
      }
  }
}
</code></pre><p>看吧，我们只需要一个构造函数和一个 onHandleIntent() 实现即可。</p>
<p>对于Service 当然也有基础一点的做法，来完成多线程的操作，只不过代码量更多了：</p>
<pre><code>public class HelloService extends Service {
  private Looper mServiceLooper;
  private ServiceHandler mServiceHandler;

  // Handler 接收来自主线程的Message
  private final class ServiceHandler extends Handler {
      public ServiceHandler(Looper looper) {
          super(looper);
      }
      @Override
      public void handleMessage(Message msg) {
         //执行任务，比如下载什么的，这里只是 让线程sleep
          long endTime = System.currentTimeMillis() + 5*1000;
          while (System.currentTimeMillis() &amp;lt; endTime) {
              synchronized (this) {
                  try {
                      wait(endTime - System.currentTimeMillis());
                  } catch (Exception e) {
                  }
              }
          }
          // 手动停止服务，来处理下一个线程
          stopSelf(msg.arg1);
      }
  }

  @Override
  public void onCreate() {
    //启动线程.  注意我们在主线程中创建了一些子线程, 这些线程都没有加锁同步. 这些现场都是后台线程，所以不会阻塞UI线程
    HandlerThread thread = new HandlerThread(&quot;ServiceStartArguments&quot;,
            Process.THREAD_PRIORITY_BACKGROUND);
    thread.start();

    // Handler开始轮询遍历了
    mServiceLooper = thread.getLooper();
    mServiceHandler = new ServiceHandler(mServiceLooper);
  }

  @Override
  public int onStartCommand(Intent intent, int flags, int startId) {
      Toast.makeText(this, &quot;service starting&quot;, Toast.LENGTH_SHORT).show();

      // 每一次请求，都会通过handler发送Message
      // startID只是为了让我们知道正在进行的是哪一个线程，以便于我们停止服务
      Message msg = mServiceHandler.obtainMessage();
      msg.arg1 = startId;
      mServiceHandler.sendMessage(msg);

      // If we get killed, after returning from here, restart
      return START_STICKY;
  }

  @Override
  public IBinder onBind(Intent intent) {
      // 不提供 binding, 所以返回空
      return null;
  }

  @Override
  public void onDestroy() {
    Toast.makeText(this, &quot;service done&quot;, Toast.LENGTH_SHORT).show();
  }
}
</code></pre><h2 id="多个App间的通信"><a href="#多个App间的通信" class="headerlink" title="多个App间的通信"></a>多个App间的通信</h2><p>首先我们要知道以下两点：</p>
<ol>
<li>Android 应用一般具有若干个Activity。每个Activity显示一个用户界面，用户可通过该界面执行特定任务（比如，查看地图或拍照）。要将用户从一个Activity转至另一Activity，应用必须使用 Intent 定义做某事的“意向”。 当我们使用诸如 startActivity() 的方法将 Intent 传递至系统时，系统会使用 Intent 识别和启动相应的应用组件。使用意向甚至可以让我们的应用开始另一个应用中包含的Activity。</li>
<li>Intent 可以为 显式 以便启动特定组件（特定的 Activity 实例）或隐式 以便启动处理意向操作（比如“拍摄照片”）的任何组件。  </li>
</ol>
<h3 id="1-向另一个应用发送用户"><a href="#1-向另一个应用发送用户" class="headerlink" title="1. 向另一个应用发送用户"></a>1. 向另一个应用发送用户</h3><p>Android最重要的功能之一，是可以操作其他应用，比如在我们的应用中，需要使用地图显示公司地址，我们无序在地图应用程序中构建Activity，而是直接创建Intent查看 地址的请求，Android系统之后启动 可以在地图上显示 地址的应用。</p>
<p><strong>1) 构建隐式的意图</strong></p>
<p>隐式意图不用声明要启动的组件类名称，而是声明操作，比如查看，编辑，发送，或者获取某项。</p>
<p>如果您我们的数据是Uri，可以这样构建Intent：</p>
<pre><code>//当我们的应用通过startActivity()调用此Intent时，电话应用会发起向指定电话号码呼叫
Uri number = Uri.parse(&quot;tel:5551234&quot;);
Intent callIntent = new Intent(Intent.ACTION_DIAL, number);  
</code></pre><p>这里还有一些其他Intent的操作和Uri数据对:</p>
<p><strong>·</strong> <code>查看地图：</code></p>
<pre><code>// 基于地址的地图位置
Uri location = Uri.parse(&quot;geo:0,0?q=1600+Amphitheatre+Parkway,+Mountain+View,+California&quot;);
// 基于经纬度的地图位置
// Uri location = Uri.parse(&quot;geo:37.422219,-122.08364?z=14&quot;); // z param is zoom level
Intent mapIntent = new Intent(Intent.ACTION_VIEW, location);
</code></pre><p><strong>·</strong> <code>查看网页：</code></p>
<pre><code>Uri webpage = Uri.parse(&quot;http://www.ocnyang.com&quot;);
Intent webIntent = new Intent(Intent.ACTION_VIEW, webpage);
</code></pre><p>有的同学会问了，我从哪里可以知道，Intent可以传递的 Uri的类型，或者其他数据类型呢？</p>
<p>答：可以查阅 <a href="https://developer.android.com/reference/android/content/Intent.html#ACTION_VIEW" target="_blank" rel="external">Google Intent 的 API</a></p>
<p><strong>2) 确认是否存在 接收意向的应用</strong></p>
<blockquote>
<p>注意：如果调用了意向，但设备上没有可用于处理意向的应用，我们的应用将崩溃。</p>
</blockquote>
<p>要确认是否存在可响应意向的可用Activity，请调用 queryIntentActivities() 来获取能够处理ntent 的Activity列表。 如果返回的 List 不为空，则可以安全地使用该意向。例如：</p>
<pre><code>PackageManager packageManager = getPackageManager();
List activities = packageManager.queryIntentActivities(intent,
        PackageManager.MATCH_DEFAULT_ONLY);
boolean isIntentSafe = activities.size() &gt; 0;
</code></pre><p>如果 isIntentSafe 是 true，则至少有一个应用将响应该意向。 如果它是 false，则没有任何应用处理该意向。</p>
<p><strong>3) 启动指定Activity</strong></p>
<p>当我指定意图后，通过startActivity(intent);就可以启动指定Activity</p>
<p>此处有一个Google官方的示例：</p>
<pre><code>// 构建Intent
Uri location = Uri.parse(&quot;geo:0,0?q=1600+Amphitheatre+Parkway,+Mountain+View,+California&quot;);
Intent mapIntent = new Intent(Intent.ACTION_VIEW, location);

// 确定意图可以被接收
PackageManager packageManager = getPackageManager();
List&lt;ResolveInfo&gt; activities = packageManager.queryIntentActivities(mapIntent, 0);
boolean isIntentSafe = activities.size() &gt; 0;

//启动指定应用
if (isIntentSafe) {
    startActivity(mapIntent);
}
</code></pre><p><strong>4) 显示应用选择器</strong></p>
<p>比如我们要完成 <strong>分享操作</strong>，用户可以使用多个App完成分享，我们应明确显示选择器对话框，如图</p>
<p><img src="http://obbu6r1mi.bkt.clouddn.com/ocnyang/android_comm/intent-chooser.png" alt="intent-chooser">  </p>
<p>要显示选择器，需要使用Intent的createChooser()方法 创建Intent，并将其传递至 startActivity()</p>
<pre><code>Intent intent = new Intent(Intent.ACTION_SEND);
...

String title = getResources().getString(R.string.chooser_title);
// Create intent to show chooser
Intent chooser = Intent.createChooser(intent, title);

// Verify the intent will resolve to at least one activity
if (intent.resolveActivity(getPackageManager()) != null) {
    startActivity(chooser);
}
</code></pre><p>这将显示一个对话框，其中有响应传递给 createChooser() 方法的意向的应用列表，并且将提供的文本用作 对话框标题</p>
<h3 id="2-接收其他Activity返回的结果"><a href="#2-接收其他Activity返回的结果" class="headerlink" title="2. 接收其他Activity返回的结果"></a>2. 接收其他Activity返回的结果</h3><p>通过Intent.startActivityForResult()来完成。</p>
<p>首先在启动另一个Activity时，我们需要指定request code以便返回结果时，我们可以正常处理它。</p>
<pre><code>static final int PICK_CONTACT_REQUEST = 1;  // The request code
...
private void pickContact() {
    Intent pickContactIntent = new Intent(Intent.ACTION_PICK, Uri.parse(&quot;content://contacts&quot;));
    pickContactIntent.setType(Phone.CONTENT_TYPE);
    startActivityForResult(pickContactIntent, PICK_CONTACT_REQUEST);
}
</code></pre><p>当用户完成操作后，返回数据，系统会调用Activity的 onActivityResult()方法，</p>
<pre><code>@Override
protected void onActivityResult(int requestCode, int resultCode, Intent data) {
    // 检查requestCode是否真确
    if (requestCode == PICK_CONTACT_REQUEST) {
        // 确保请求时成功的
        if (resultCode == RESULT_OK) {
           // 完成我们的业务逻辑
        }
    }
}
</code></pre><p>为了成功处理结果，我们必须了解Intent的格式，比如联系人返回的是带内容的URI，照相机返回的是Bitmap<br>如何根据返回的URI来读取数据，我们需要对ContentResolver 和 ContentProvider 有了解</p>
<p>下面就是一个三者结合的获取联系人的实例：</p>
<pre><code>@Override
protected void onActivityResult(int requestCode, int resultCode, Intent data) {
    // 检查requestCode
    if (requestCode == PICK_CONTACT_REQUEST) {
        // 确保请求成功
        if (resultCode == RESULT_OK) {
            //获得选择的联系人的URI
            Uri contactUri = data.getData();
            // 我们只需要NUMBER这一列的信息，
            String[] projection = {Phone.NUMBER};

            // 显示根据NUMBER查询的结果
            // We don&apos;t need a selection or sort order (there&apos;s only one result for the given URI)
            // 在这里我们并没有对查询的结果进行排序，因为在主线程中进行这种数据库操作，有可能阻塞线程
            //优化方案是异步完成排序的操作，这里只是展示多个App间的通信
            Cursor cursor = getContentResolver()
                    .query(contactUri, projection, null, null, null);
            cursor.moveToFirst();

            //从NUMBER那一列当中取回phone NUMBER
            int column = cursor.getColumnIndex(Phone.NUMBER);
            String number = cursor.getString(column);
            //接下来就是要操作这些phone number了
        }
    }
}
</code></pre><h3 id="3-接收其他Activity返回的结果"><a href="#3-接收其他Activity返回的结果" class="headerlink" title="3. 接收其他Activity返回的结果"></a>3. 接收其他Activity返回的结果</h3><p>要允许其他应用开始您的Activity，需要 在相应元素的宣示说明文件中添加一个 元素。</p>
<p>例如，此处有一个在数据类型为文本或图像时处理 ACTION_SEND 意向的意向过滤器：</p>
<pre><code>&lt;activity android:name=&quot;ShareActivity&quot;&gt;
    &lt;intent-filter&gt;
        &lt;action android:name=&quot;android.intent.action.SEND&quot;/&gt;
        &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt;
        &lt;data android:mimeType=&quot;text/plain&quot;/&gt;
        &lt;data android:mimeType=&quot;image/*&quot;/&gt;
    &lt;/intent-filter&gt;
&lt;/activity&gt;
</code></pre><p>定义操作，通常是系统定义的值之一，比如ACTION_SEND 或 ACTION_VIEW。</p>
<p>定义与Intent关联的数据，只需通过 android:mimeType 指定我们接收的数据类型，比如text/plain 或 image/jpeg。</p>
<p>所有的隐式Intent，都使用 CATEGORY_DEFAULT 进行定义</p>
<h3 id="4-处理Activity中的Intent"><a href="#4-处理Activity中的Intent" class="headerlink" title="4. 处理Activity中的Intent"></a>4. 处理Activity中的Intent</h3><p>当Activity开始时，调用getIntent检索开始Activity的Intent，</p>
<pre><code>@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);

    setContentView(R.layout.main);

    Intent intent = getIntent();
    Uri data = intent.getData();

    // 指出接收的数据类型
    if (intent.getType().indexOf(&quot;image/&quot;) != -1) {
        // 处理带有图片的Intent
    } else if (intent.getType().equals(&quot;text/plain&quot;)) {
        // 处理带有文本的Intent
    }
}
</code></pre><h3 id="5-向指定Activity中返回数据"><a href="#5-向指定Activity中返回数据" class="headerlink" title="5. 向指定Activity中返回数据"></a>5. 向指定Activity中返回数据</h3><p>只需调用setResult指定结果代码和Intent</p>
<pre><code>Intent result = new Intent(&quot;com.example.RESULT_ACTION&quot;, Uri.parse(&quot;content://result_uri&quot;);
setResult(Activity.RESULT_OK, result);
finish();
</code></pre><p>记住必须为结果指定结果码，通常为 RESULT_OK 或 RESULT_CANCELED。</p>
<p>我们也可以在Intent中 用Bundle存储额外的信息</p>
<p>细心的同学可能发现一个问题：</p>
<p>启动 Activity 有 startActivity() 和 startActivityForResult() 两种启动方式，返回结果的形式id偶有 setResult() 吗？</p>
<p>如果开启当前Activity的Intent可能需要结果，只需调用 setResult()。 如果原始 Activity 已调用 startActivityForResult()，则系统将向其传递您提供给 setResult() 的结果；否则，会忽略结果。</p>
<h2 id="使用大型开源框架完成组件间的通信"><a href="#使用大型开源框架完成组件间的通信" class="headerlink" title="使用大型开源框架完成组件间的通信"></a>使用大型开源框架完成组件间的通信</h2><p>Github上非常火的两大通信组件EventBus和otto：</p>
<h3 id="1-EventBus"><a href="#1-EventBus" class="headerlink" title="1. EventBus"></a>1. EventBus</h3><p>EventBus 是一个 Android 事件发布/订阅框架，通过解耦发布者和订阅者简化 Android 事件传递，这里的事件可以理解为消息，本文中统一称为事件。事件传递既可用于 Android 四大组件间通讯，也可以用户异步线程和主线程间通讯等等。</p>
<p>传统的事件传递方式包括：Handler、BroadCastReceiver、Interface 回调，相比之下 EventBus 的优点是代码简洁，使用简单，并将事件发布和订阅充分解耦。</p>
<p><strong>1）概念：</strong></p>
<p>事件(Event)：又可称为消息，本文中统一用事件表示。其实就是一个对象，可以是网络请求返回的字符串，也可以是某个开关状态等等。事件类型(EventType)指事件所属的 Class。</p>
<p>事件分为一般事件和 Sticky 事件，相对于一般事件，Sticky 事件不同之处在于，当事件发布后，再有订阅者开始订阅该类型事件，依然能收到该类型事件最近一个 Sticky 事件。</p>
<p>订阅者(Subscriber)：订阅某种事件类型的对象。当有发布者发布这类事件后，EventBus 会执行订阅者的 onEvent 函数，这个函数叫事件响应函数。订阅者通过 register 接口订阅某个事件类型，unregister 接口退订。订阅者存在优先级，优先级高的订阅者可以取消事件继续向优先级低的订阅者分发，默认所有订阅者优先级都为 0。</p>
<p>发布者(Publisher)：发布某事件的对象，通过 post 接口发布事件。</p>
<p>本项目较为简单，总体设计和流程图：</p>
<p><img src="http://obbu6r1mi.bkt.clouddn.com/ocnyang/android_comm/EventBus-Publish-Subscribe.png" alt="EventBus-Publish-Subscribe">  </p>
<p>使用方式：</p>
<p>build.gradle 中加入依赖</p>
<pre><code>compile &apos;org.greenrobot:eventbus:3.0.0&apos;
</code></pre><p>代码中指需三步</p>
<blockquote>
<p><strong>1.</strong> 定义事件：只需要是一个Java类</p>
</blockquote>
<pre><code>public class MessageEvent {
    public final String message;
    public MessageEvent(String message) {
        this.message = message;
    }
}
</code></pre><blockquote>
<p><strong>2.</strong> 完成订阅者</p>
</blockquote>
<pre><code>//MessageEvent被Eventbus post提交的时候 将会回调这个方法
//这种方式 提示我们可以直接定义自己的事件
@Subscribe
public void onMessageEvent(MessageEvent event){
    Toast.makeText(getActivity(), event.message, Toast.LENGTH_SHORT).show();
}

// 当一些其他事件post提交的时候，回调这个方法
@Subscribe
public void handleSomethingElse(SomeOtherEvent event){
    doSomethingWith(event);
</code></pre><blockquote>
<p>在Activity或者Fragment中绑定订阅者</p>
</blockquote>
<pre><code>@Override
public void onStart() {
    super.onStart();
    EventBus.getDefault().register(this);
}

@Override
public void onStop() {
   EventBus.getDefault().unregister(this);
    super.onStop();
}
</code></pre><blockquote>
<p><strong>3.</strong> 发布事件：</p>
</blockquote>
<pre><code>EventBus.getDefault().post(new MessageEvent(&quot;Hello everyone!&quot;));
</code></pre><h2 id="本文参考并翻译"><a href="#本文参考并翻译" class="headerlink" title="本文参考并翻译"></a>本文参考并翻译</h2><blockquote>
<p><a href="http://www.androidchina.net/5028.html#rd" target="_blank" rel="external">文章来源</a></p>
</blockquote>
<ul>
<li><a href="https://developer.android.com/training/basics/fragments/communicating.html" target="_blank" rel="external">Google 课程 Communicating with Other Fragments</a></li>
<li><a href="https://developer.android.com/guide/components/aidl.html" target="_blank" rel="external">Google 解释 AIDL进程间通信</a></li>
<li><a href="https://developer.android.com/training/multiple-threads/communicate-ui.html" target="_blank" rel="external">Google 解释 Handler</a></li>
<li><a href="https://developer.android.com/reference/android/os/AsyncTask.html" target="_blank" rel="external">Google 解释 AsyncTask</a></li>
<li><a href="https://developer.android.com/reference/android/content/BroadcastReceiver.html" target="_blank" rel="external">Google BroadcastReceiver API</a></li>
<li><a href="https://developer.android.com/training/basics/intents/index.html?hl=vi" target="_blank" rel="external">Google 课程 Interacting with Other Apps</a></li>
<li><a href="https://developer.android.com/guide/topics/providers/content-provider-creating.html" target="_blank" rel="external">Google 解释 contentprovider</a></li>
<li><a href="https://developer.android.com/reference/android/content/BroadcastReceiver.html" target="_blank" rel="external">Google BroadcastReceiver 课程</a></li>
<li><a href="https://developer.android.com/guide/components/services.html" target="_blank" rel="external">Google Service 课程</a></li>
<li><a href="https://developer.android.com/guide/components/processes-and-threads.html#" target="_blank" rel="external">Google 解释 进程和线程</a></li>
<li><a href="http://greenrobot.org/eventbus/documentation/" target="_blank" rel="external">EventBus官方文档</a></li>
</ul>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        
  <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
    <div>坚持好文章的分享，您的支持将是对我最大的鼓励！</div>
    <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
      <span>赏</span>
    </button>
    <div id="QR" style="display: none;">
      
        <div id="wechat" style="display: inline-block">
          <img id="wechat_qr" src="/path/to/wechat-reward-image.png" alt="OCN.Yang WeChat Pay"/>
          <p>微信打赏</p>
        </div>
      
      
        <div id="alipay" style="display: inline-block">
          <img id="alipay_qr" src="/path/to/alipay-reward-image.jpg" alt="OCN.Yang Alipay"/>
          <p>支付宝打赏</p>
        </div>
      
    </div>
  </div>


      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Android/" rel="tag"># Android</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/01/24/hello-world/" rel="next" title="Hello World!">
                <i class="fa fa-chevron-left"></i> Hello World!
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/02/13/DonkeyAndPrincess/" rel="prev" title="向日葵公主与驴的爱情故事">
                向日葵公主与驴的爱情故事 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2017/02/13/AndroidComm/"
           data-title="详解 Android 通信" data-url="http://ocnyang.com/2017/02/13/AndroidComm/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/ocnyang.png"
               alt="OCN.Yang" />
          <p class="site-author-name" itemprop="name">OCN.Yang</p>
           
              <p class="site-description motion-element" itemprop="description">拼凑江山，只为遇见你时自己不那么不堪</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">47</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">9</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">36</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="http://www.jianshu.com/users/e61d05cbf47e/latest_articles" target="_blank" title="简书">
                  
                    <i class="fa fa-fw fa-pencil"></i>
                  
                  简书
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://github.com/ocnyang" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/shedoor" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://love.shedoor.net/" target="_blank" title="Meet you">
                  
                    <i class="fa fa-fw fa-heartbeat"></i>
                  
                  Meet you
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              Links
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://www.shedoor.net/" title="个人" target="_blank">个人</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#一文详尽-Android-通信：四大组件之间-amp-进程间-amp-线程间-amp-多个App间"><span class="nav-number">1.</span> <span class="nav-text">一文详尽 Android 通信：四大组件之间 & 进程间 & 线程间 & 多个App间</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#本文大纲"><span class="nav-number">1.1.</span> <span class="nav-text">本文大纲</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Activity通信"><span class="nav-number">1.2.</span> <span class="nav-text">Activity通信</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Activity-和-Activity"><span class="nav-number">1.2.1.</span> <span class="nav-text">Activity 和 Activity</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Activity-和-Fragment，Service，BrodcastReceiver"><span class="nav-number">1.2.2.</span> <span class="nav-text">Activity 和 Fragment，Service，BrodcastReceiver</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Fragment"><span class="nav-number">1.3.</span> <span class="nav-text">Fragment</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-Fragment-与Activity通信"><span class="nav-number">1.3.1.</span> <span class="nav-text">1. Fragment 与Activity通信</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-Fragment-与-多个Fragment通信"><span class="nav-number">1.3.2.</span> <span class="nav-text">2. Fragment 与 多个Fragment通信</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Service"><span class="nav-number">1.4.</span> <span class="nav-text">Service</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Service-与-Activity-通信"><span class="nav-number">1.4.1.</span> <span class="nav-text">Service 与 Activity 通信</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AIDL-完成进程间通信"><span class="nav-number">1.5.</span> <span class="nav-text">AIDL 完成进程间通信</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程间通信"><span class="nav-number">1.6.</span> <span class="nav-text">线程间通信</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多个App间的通信"><span class="nav-number">1.7.</span> <span class="nav-text">多个App间的通信</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-向另一个应用发送用户"><span class="nav-number">1.7.1.</span> <span class="nav-text">1. 向另一个应用发送用户</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-接收其他Activity返回的结果"><span class="nav-number">1.7.2.</span> <span class="nav-text">2. 接收其他Activity返回的结果</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-接收其他Activity返回的结果"><span class="nav-number">1.7.3.</span> <span class="nav-text">3. 接收其他Activity返回的结果</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-处理Activity中的Intent"><span class="nav-number">1.7.4.</span> <span class="nav-text">4. 处理Activity中的Intent</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-向指定Activity中返回数据"><span class="nav-number">1.7.5.</span> <span class="nav-text">5. 向指定Activity中返回数据</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用大型开源框架完成组件间的通信"><span class="nav-number">1.8.</span> <span class="nav-text">使用大型开源框架完成组件间的通信</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-EventBus"><span class="nav-number">1.8.1.</span> <span class="nav-text">1. EventBus</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#本文参考并翻译"><span class="nav-number">1.9.</span> <span class="nav-text">本文参考并翻译</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2014 - 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">OCN.Yang</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      本站访客数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      人次
    </span>
  

  
    <span class="site-pv">
      本站总访问量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>


        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"ocnyang"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  
















  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("gh3omnCzhrHskUI74veM8V99-gzGzoHsz", "S5X90d5uKqp25VMacYGLwL60");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  

</body>
</html>
