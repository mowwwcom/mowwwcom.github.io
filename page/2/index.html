<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT, OCN.Yang, Android, 杨欧神" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="拼凑江山，只为遇见你时自己不那么不堪">
<meta property="og:type" content="website">
<meta property="og:title" content="杨欧神/OCN.Yang">
<meta property="og:url" content="http://ocnyang.com/page/2/index.html">
<meta property="og:site_name" content="杨欧神/OCN.Yang">
<meta property="og:description" content="拼凑江山，只为遇见你时自己不那么不堪">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="杨欧神/OCN.Yang">
<meta name="twitter:description" content="拼凑江山，只为遇见你时自己不那么不堪">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://ocnyang.com/page/2/"/>





  <title> 杨欧神/OCN.Yang </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?923326cdfba9134256dbbf5887c8ce38";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>










  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">杨欧神/OCN.Yang</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">我问佛：如何让心不再感到孤单？<br>佛曰：每一颗心生来就是孤单而残缺的，多数带着这种残缺度过一生，只因与能使它圆满的另一半相遇时，不是疏忽错过，就是已失去了拥有它的资格</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-circle-o-notch"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-list"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-hourglass-start"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-efall">
          <a href="/categories/还相信爱情/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-key"></i> <br />
            
            menu.efall
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user-secret"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://ocnyang.com/2016/11/24/INWaitRainStopWithoutU/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="OCN.Yang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/ocnyang.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="杨欧神/OCN.Yang">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/24/INWaitRainStopWithoutU/" itemprop="url">
                  我不等伞，也不等雨停
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-11-24T17:03:15+08:00">
                2016-11-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/还相信爱情/" itemprop="url" rel="index">
                    <span itemprop="name">还相信爱情</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2016/11/24/INWaitRainStopWithoutU/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/11/24/INWaitRainStopWithoutU/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2016/11/24/INWaitRainStopWithoutU/" class="leancloud_visitors" data-flag-title="我不等伞，也不等雨停">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="我不等伞，也不等雨停"><a href="#我不等伞，也不等雨停" class="headerlink" title="我不等伞，也不等雨停"></a>我不等伞，也不等雨停</h1><p><img src="http://obbu6r1mi.bkt.clouddn.com/ocnyang/forloneliness.jpg" alt="长夜漫漫，愿你有人爱。">  </p>
<h2 id="（一）"><a href="#（一）" class="headerlink" title="（一）"></a>（一）</h2><p>漂流瓶里收到了一条“奇怪”的消息是这么说的：说来也不容易，你会收着我的瓶子，或许因为网络，咫尺天涯，或者因为网络，万里非途；无论我们各自身处何方，但这一刻，我们或许有相似的地方。太过熟悉的人，只能够做知己，初次邂逅的人，会是一眼万年。我会被你扔在海里，但你，依旧会是我的远方。</p>
<p>说实话，当看到的时候，还是有那么一份真诚的感动涌上心头的，能够被一个陌生人当作远方，并且被“告白”，确确实实称的上是一种缘分。</p>
<p>但是细细品来，我却尝到了落寞，化不开的悲伤流露字里行间。我相信这不是一个陌生人应该说出来的话。</p>
<p>我当即就给了一份回复，希望能给这个来自远方的问候一些温暖：<em>我相信这个世界上一定会有一个你爱的人，他会穿过汹涌的人潮，笔直的走过田野、乡间和繁华的城市，然后拿着一颗用力跳动的心脏，捧着满腔的热血和沉甸甸的爱，走向你，抓紧你，去交换你的真心，他一定会找到你的，你一定要等下去啊！</em></p>
<h2 id="（二）"><a href="#（二）" class="headerlink" title="（二）"></a>（二）</h2><p><strong>百无一用是深情，不屑一顾最相思。</strong></p>
<p>在爱情面前，哪怕没有经历过的我，也很佩服那么一种人：只要知道了一段感情不适合，再难过也狠下心的说不见，再不舍也能假装洒脱的大步向前，再留恋也能勇敢的不回头。</p>
<p>哪怕转身的一瞬间很孤单，但是你真的不知道你的背影有多么的好看！</p>
<p>当然佩服归佩服，羡慕归羡慕，我还是知道，再百毒不侵的内心，往往也会被一句简单的安慰打败；再刀枪不入的伪装，也常常在懂你的面前投降；再怎么坚强的面容，也往往会有痛哭的时候。</p>
<p>而且我还知道，这个世界上可能最难过的事情不是你遇而不见，而是你已经遇见了，得到了，却是又匆忙的失去，然后在你的心上便是一道疤。它一直跟随着你，它让你什么时候疼，就什么时候疼，那可能会成为一直好不了的伤。</p>
<p>你希望着自己的棱角被时间磨平，希望会拔掉身上的刺，希望会学着对讨厌的人微笑，变得波澜不惊，希望变得不动声色。</p>
<p>可能么？</p>
<h2 id="（三）"><a href="#（三）" class="headerlink" title="（三）"></a>（三）</h2><p><strong>愿有岁月可回首，且以深情共白头？</strong></p>
<p>有人说要感谢前任让你成长，是他（她）让你变得更好。</p>
<p>可我总觉得不是这样。那些痛不欲生撕心裂肺的日子，都是你咬着牙一天天熬过来的啊。创伤这种东西永远都只是创伤，它只会演化为消磨力量的腐蚀剂。从创伤里得到成长，怎能和在无忧无虑的日子里享受阳光，在该有担当的日子里勇气十足的上阵相比呢？</p>
<p><em>凭什么要谢别人？！你得谢谢自己。</em></p>
<p>而且要知道，但凡死缠烂打的人，大都不是真的深爱你，那只是在跟自己赛跑，跟自己别扭过不去。真正爱你的人，是做不到死缠烂打，因为自尊不允许。我一直深信，爱就是把最好的一切给予对方，包括尊严。</p>
<p>哪怕有多多少少浅浅淡淡的转身，那都是旁人看不懂的情深。</p>
<p>如果说很多人在我们的生命中都经历着三个阶段：重要，很重要，不重要。也许你并不愿承认，但是事实上这件事最经不住内心拷问。</p>
<p>在时间的淘洗下，多少信誓旦旦都渐次苍白？人世的沧桑就在这里：我们总是在誓言那边纯粹，却在现实这边很崩溃。</p>
<p>失望积累的太多，再多的爱也会碎落满地，无论怎样还是会觉得无能为力，离开的不一定在意，但有些人也许只适合留在回忆里。</p>
<p>终究你会觉得人生是一场盛大的相遇，我也曾想义无反顾的等你，可是对不起。</p>
<h2 id="（四）"><a href="#（四）" class="headerlink" title="（四）"></a>（四）</h2><p><strong>你以为说了分手就能不见面；你以为说了再见就能不想念。</strong></p>
<p>我们迫不及待的想要和喜欢的人携手相伴一生；迫不及待的想要参与对方的生活，可结果往往是，越是爱你的人，越没那么爱你。</p>
<p>所以你总是在意别人的感受，宁愿自己受委屈，也不想别人不开心。</p>
<p>对方一失落，你就紧张；对方一道歉，你就心软，甚至觉得对方无所谓的生气都是在计较于自己的某件事情。</p>
<p>你傻傻的背着别人的快乐，有时候僵在原地喘不过气，但我知道，你的敏感是因为善良。</p>
<p>我希望善良的你最后不会吃亏，会有更多人用力的爱你，去作为回报。</p>
<p>很累的时候，就去听几首歌放空吧；很烦的时候，就去楼下跑步吧；很焦虑的时候，就去洗把脸清醒下。</p>
<p>爱的人爱不到，就先爱自己；等待的人还没来，就想做自己喜欢的事。</p>
<p>你就是一本书，何必非要当别人的书签。难过一会就行了，时间如此宝贵，哪能都浪费在难过上。</p>
<h2 id="（五）"><a href="#（五）" class="headerlink" title="（五）"></a>（五）</h2><p><strong>白茶轻欢无别事，我在等风也在等你。</strong></p>
<p>你若爱，生活哪里都可以爱；你若恨，生活哪里都可以恨；你若感恩，处处可感恩；你若成长，事事皆可成长。</p>
<p>长大之后，我们要明白，不是世界选择了你，是你选择了这个世界。</p>
<p>既然无处可躲，不如傻乐；既然无处可逃，不如喜悦；既然没有净土，不如静心；既然没有如愿，不如释然吧。</p>
<p>但我唯愿有佳人陪你走，我独拥浊风烈酒。</p>
<p><em>愿漂泊的人都有酒喝，愿孤独的人都会唱歌。敬你一杯酒，从此朝前走，往事不回头，未来不将就。</em></p>
<p>我干杯，你随意。</p>
<p>因为我不等伞，也不等雨停。</p>
<blockquote>
<p>摘录<br><a href="http://www.jianshu.com/p/0714150f4544#" target="_blank" rel="external">文／小五是个好少年（简书作者）</a></p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://ocnyang.com/2016/11/23/Android7Shortcuts/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="OCN.Yang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/ocnyang.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="杨欧神/OCN.Yang">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/23/Android7Shortcuts/" itemprop="url">
                  Android 7.1 新特性：快捷方式 Shortcuts
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-11-23T16:03:15+08:00">
                2016-11-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android教程系列/" itemprop="url" rel="index">
                    <span itemprop="name">Android教程系列</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2016/11/23/Android7Shortcuts/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/11/23/Android7Shortcuts/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2016/11/23/Android7Shortcuts/" class="leancloud_visitors" data-flag-title="Android 7.1 新特性：快捷方式 Shortcuts">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Android-7-1-新特性：快捷方式-Shortcuts"><a href="#Android-7-1-新特性：快捷方式-Shortcuts" class="headerlink" title="Android 7.1 新特性：快捷方式 Shortcuts"></a>Android 7.1 新特性：快捷方式 Shortcuts</h1><h2 id="一、Shortcuts-介绍"><a href="#一、Shortcuts-介绍" class="headerlink" title="一、Shortcuts 介绍"></a>一、Shortcuts 介绍</h2><p>Android 7.1 允许 App 自定义 Shortcuts，类似 iOS 的 3D touch。通过在桌面长按 App 弹出 Shortcut 列表，点击某个 Shortcut 快速进入某项操作，同时 Shortcut 可以拖动到桌面进行固定，如下图：  </p>
<p><img src="http://obbu6r1mi.bkt.clouddn.com/ocnyang/android-7.1-app-shortcuts.jpg" alt="android-7.1-app-shortcuts">  </p>
<h3 id="1-Shortcuts-作用及分类"><a href="#1-Shortcuts-作用及分类" class="headerlink" title="1. Shortcuts 作用及分类"></a>1. Shortcuts 作用及分类</h3><p>Shortcuts 为 App 常用操作提供了快速访问的方式，如上面日历的新建提醒。  </p>
<p>这个功能目前只能在 <a href="http://ocnyang.com/">Android 7.1</a> 系统桌面进行使用，这个依然保留着“应用抽屉”古老设计的产品国内应该没多少用户。三方桌面可以通过 API 接入这个功能。<br>目前支持 Shortcut 的应用主要还是 Google 的 App，看到有即刻的朋友说他们在 7.1 系统发布时快速支持了这个功能并上线，速度很赞。  </p>
<p>类似 BroadcastReceiver 可通过静态和动态方式注册，Shortcuts 也可以通过静态和动态方式添加。  </p>
<h3 id="2-静态-Shortcuts-Static-Shortcuts"><a href="#2-静态-Shortcuts-Static-Shortcuts" class="headerlink" title="2. 静态 Shortcuts(Static Shortcuts)"></a>2. 静态 Shortcuts(Static Shortcuts)</h3><p>静态 ShortcutsStatic Shortcuts通过在 Manifest 中声明添加。缺点是不可以修改，只能通过应用升级来添加新的静态 Shortcuts。添加主要分为两步：  </p>
<p><strong>2.1</strong>  AndroidManifest.xml 的 Main Launcher 对应的 Activity 内添加 <code>meta-data
meta-data name</code> 为<code>android.app.shortcuts</code>，如下：</p>
<pre><code>&lt;application
    ……&gt;
    &lt;activity android:name=&quot;.main.MainActivity&quot;&gt;
        &lt;intent-filter&gt;
            &lt;action android:name=&quot;android.intent.action.MAIN&quot;/&gt;

            &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot;/&gt;
        &lt;/intent-filter&gt;

        &lt;meta-data
            android:name=&quot;android.app.shortcuts&quot;
            android:resource=&quot;@xml/shortcuts&quot;/&gt;
    &lt;/activity&gt;
&lt;/application&gt;
</code></pre><p>必须在 Main Launcher 对应的 Activity 内设置，其中android:resource指向定义了 shortcuts 的资源文件。</p>
<p><strong>2.2</strong> 资源文件中定义具体的 shortcuts<br>res 目录下新建 xml 文件夹，并新建 shortcuts.xml 文件，内容如下：  </p>
<pre><code>&lt;shortcuts xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;
    &lt;shortcut
        android:enabled=&quot;true&quot;
        android:icon=&quot;@drawable/search&quot;
        android:shortcutId=&quot;search&quot;
        android:shortcutDisabledMessage=&quot;@string/disabled&quot;
        android:shortcutLongLabel=&quot;@string/menu_label&quot;
        android:shortcutShortLabel=&quot;@string/launcher_label&quot;&gt;
        &lt;intent
            android:action=&quot;android.intent.action.VIEW&quot;
            android:targetClass=&quot;cn.trinea.android.demo.SearchActivity&quot;
            android:targetPackage=&quot;cn.trinea.android.demo&quot;/&gt;
        &lt;intent
            ……/&gt;
    &lt;/shortcut&gt;
    ……
&lt;/shortcuts&gt;
</code></pre><p>以shortcuts元素为根，可以包含多个shortcut元素，每个shortcut元素表示一个 shortcut。其中属性分别表示：  </p>
<ol>
<li>shortcutId表示 shortcut 唯一标识符，相同的 shortcutId 会被覆盖。必须字段。  </li>
<li>shortcutShortLabel为将 shortcut 拖动到桌面时显示的名字，官方建议不超过 10 个字符，必须字段。  </li>
<li>shortcutLongLabel为 shortcut 列表中每个 shortcut 的名字，不宜过长，如果过长或未设置默认会显示 ShortLabel，官方建议不超过 25 个字符。可选字段。  </li>
<li>icon为 shortcut 的 icon，在列表展示和拖动到桌面时显示需要，可选字段。  </li>
<li>enabled表示 shortcut 是否可用，false 表示禁用。xml 中这个属性几乎没有被设置为 false 的实际场景，具体原因可见<strong>6.7 如何更好的删除(废弃)老的 Shortcut</strong>中介绍。  </li>
<li>shortcutDisabledMessage为已固定在桌面的 shortcut 被 Disabled 后点击时的 Toast 提示内容。可选字段。  </li>
<li>intent为点击 shortcut 时响应的 Intent，必须字段。  </li>
</ol>
<p>这里可以添加多个 Intent，但点击时不会启动所有 Intent，而是启动最后一个 Intent，在这个 Intent 回退时会启动它前面一个 Intent，相当于自动将所有 Intent 添加到了堆栈。<br>对于先跳转到某个页面，Back 键希望退回主页而不是结束 App 这类场景，多个 Intents 挺实用的。  </p>
<blockquote>
<p><strong>intent可设置属性包括：</strong><br>android:action、android:data、android:mimeType、android:targetClass、android:targetPackage<br>其中android:action为必须属性。  </p>
</blockquote>
<h3 id="3-动态-Shortcuts-Dynamic-Shortcuts"><a href="#3-动态-Shortcuts-Dynamic-Shortcuts" class="headerlink" title="3. 动态 Shortcuts(Dynamic Shortcuts)"></a>3. 动态 Shortcuts(Dynamic Shortcuts)</h3><p>动态 ShortcutsDynamic Shortcuts 通过 ShortcutManager API 进行操作。可以动态添加、修改、删除。  </p>
<pre><code>if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.N_MR1) {
    return;
}

ShortcutManager shortcutManager = getSystemService(ShortcutManager.class);
ShortcutInfo shortcut = new ShortcutInfo.Builder(this, &quot;id1&quot;)
    .setShortLabel(&quot;trinea.cn&quot;)
    .setLongLabel(&quot;Open trinea.cn&quot;)
    .setDisabledMessage(&quot;Disabled&quot;)
    .setIcon(Icon.createWithResource(context, R.drawable.trinea_cn))
    .setIntent(new Intent(Intent.ACTION_VIEW, Uri.parse(&quot;http://www.trinea.cn/&quot;)))
    .build();
shortcutManager.setDynamicShortcuts(Arrays.asList(shortcut));
</code></pre><p>通过ShortcutInfo.Builder新建 ShortcutInfo，再通过shortcutManager添加即可。其他：</p>
<ol>
<li>setDynamicShortcuts(List)可以替换并添加所有 shortcut 列表；  </li>
<li>addDynamicShortcuts(List)可以添加新的 shortcut 到列表，超过最大个数会报异常；  </li>
<li>updateShortcuts(List)可以更新一组 shortcuts；  </li>
<li>removeDynamicShortcuts(List)和removeAllDynamicShortcuts() 可以删除部分或所有 shortcuts。  </li>
</ol>
<p>ShortcutInfo的属性与 xml 中定义字段含义一致，shortcutId shortcutShortLabel intent 是必须设置的字段，并且intent必须设置Action。  </p>
<h3 id="4-固定的-Shortcuts-Pinned-Shortcuts"><a href="#4-固定的-Shortcuts-Pinned-Shortcuts" class="headerlink" title="4. 固定的 Shortcuts(Pinned Shortcuts)"></a>4. 固定的 Shortcuts(Pinned Shortcuts)</h3><p>指通过拖动固定到桌面的 Shortcuts，App 不可以添加、修改、删除这些 Shortcuts，只能禁用他们。即便 App 内删除了某个 Shorcut，对应的已固定到桌面的 Shortcuts 也不会被删除。  </p>
<p>可以通过：  </p>
<ol>
<li>getPinnedShortcuts()得到所有固定的 Shortcuts 的信息。  </li>
<li>disableShortcuts(List)或disableShortcuts(List, CharSequence)禁用动态的 Shortcuts。  </li>
</ol>
<p>对于静态的 Shortcuts 需要在资源文件中设置<code>android:enabled=&quot;false&quot;</code>进行禁用，不过没有必要，静态 Shortcuts 可直接通过删除达到禁用的效果，具体原因可见<strong>6.7 如何更好的删除(废弃)老的 Shortcut</strong>中介绍。</p>
<p>静态 Shortcuts 和动态 Shortcuts 是有最大个数限制的，默认为 5，超过最大个数后添加会报异常。而固定的 Shortcuts 并没有个数限制，并且固定的 Shortcut 对应的 Shortcut 即便被动态删除了，依然可以通过 id 进行 Update 操作。  </p>
<h3 id="5-其他"><a href="#5-其他" class="headerlink" title="5. 其他"></a>5. 其他</h3><h4 id="5-1-动态-Shortcuts-与静态-Shortcuts-区别"><a href="#5-1-动态-Shortcuts-与静态-Shortcuts-区别" class="headerlink" title="5.1 动态 Shortcuts 与静态 Shortcuts 区别"></a>5.1 动态 Shortcuts 与静态 Shortcuts 区别</h4><ol>
<li>静态 Shortcuts 只能通过升级应用修改，动态 Shortcuts 随时可以修改；</li>
<li>静态 Shortcuts 的 Intent 无法设置 Flag，默认为<code>FLAG_ACTIVITY_NEW_TASK</code>和<code>FLAG_ACTIVITY_CLEAR_TASK Flag</code>，即若应用运行中会清除所有已存在的 Activity。动态 Shortcuts 的 Intent 可以设置 Flag；</li>
<li>静态 Shortcuts 的rank系统默认根据声明顺序设置，动态 Shortcuts 的rank可以通过setRank(int rank)接口主动设置，rank 不能小于 0，值越大表示在 shortcut 列表展示时离 App Icon 越远。静态 Shortcuts 默认比动态 Shortcuts 离 App Icon 更近。</li>
<li>静态 Shortcuts 删除可以直接删除，动态 Shortcuts 建议通过禁用删除；</li>
</ol>
<h4 id="5-2-动态-Shortcuts-操作的频率问题"><a href="#5-2-动态-Shortcuts-操作的频率问题" class="headerlink" title="5.2 动态 Shortcuts 操作的频率问题"></a>5.2 动态 Shortcuts 操作的频率问题</h4><p>当应该完全退到后台<a href="http://ocnyang.com/">(无 Activity 或 Service 在前台时)</a>，其操作 Shortcut(包括添加、删除、修改) 的频率是受限的。可通过isRateLimitingActive()查询是否已受限，true表示已受限。  </p>
<h4 id="5-3-跟踪-Shorcut-使用情况"><a href="#5-3-跟踪-Shorcut-使用情况" class="headerlink" title="5.3 跟踪 Shorcut 使用情况"></a>5.3 跟踪 Shorcut 使用情况</h4><p>在 Shortcut 被选择或者其关联的操作被操作时需调用reportShortcutUsed(String shortcutId)接口上报数据，为了方便启动器收集应用 Shortcuts 使用情况，以便未来进行预测或者向开发者展示哪些操作适合作为 Shortcuts 以及其优先级。  </p>
<blockquote>
<p>PS：这个接口其实挺尴尬的，一方面需要 App 主动上报，侵入性太强。另一方面这个预测功能未来也不好加到 Shortcuts 推荐里，更多是个开发工具相关功能。<br>最好是由启动器自己纯粹收集 Shortcut 被选择的使用情况数据，而不需要统计 Shortcut 被关联操作通过其他方式调用的使用情况数据。至于哪些操作适合作为 Shortcuts，开发者大可通过其他监控 SDK 去判断。</p>
</blockquote>
<h4 id="5-4-应用备份"><a href="#5-4-应用备份" class="headerlink" title="5.4 应用备份"></a>5.4 应用备份</h4><p>如果应用通过备份恢复到另外一台机器上，固定的 Shortcuts 是可以直接恢复的，不过启动器不保存这些 Shortcut 的 icon，所以应用内需要存在这些 icon 对应的资源以便启动器能找到。  </p>
<p>静态 Shortcuts 需要应用重新安装、升级才能生效。<br>动态 Shortcuts 需要相应代码被执行过才能生效。</p>
<h2 id="二、Shortcuts-一些实践-amp-问题"><a href="#二、Shortcuts-一些实践-amp-问题" class="headerlink" title="二、Shortcuts 一些实践&amp;问题"></a>二、Shortcuts 一些实践&amp;问题</h2><p><img src="http://obbu6r1mi.bkt.clouddn.com/ocnyang/android-7.1-app-shortcuts-3.jpg" alt=""><br><img src="http://obbu6r1mi.bkt.clouddn.com/ocnyang/android-7.1-app-shortcuts-4.jpg" alt=""></p>
<h3 id="6-最佳实践"><a href="#6-最佳实践" class="headerlink" title="6. 最佳实践"></a>6. 最佳实践</h3><p>这块官网已经给出了一部分建议，包括：  </p>
<ol>
<li>设计上和系统 App 的 Shortcuts 保持一致。</li>
<li>最多添加 4 个 Shortcuts 以保持在启动器中显示的样式最佳<br>目前虽然说是 5 个，但实际最多只能添加 4 个，可见<strong>7.2 Shortcut 添加或修改无效</strong>中介绍。</li>
<li>限制 Label 长度<br>其中shortcutShortLabel建议不超过 10 个字符，shortcutLongLabel 建议不超过 25 个字符。这块可能有些问题，可见<strong>7.1 LongLabel 和 ShortLabel</strong>中介绍。</li>
<li>记录 Shortcut 及其对应操作使用记录。<br>这个在<strong>5.3 跟踪 Shorcut 使用情况</strong>中已经介绍了。</li>
<li>只在 Shortcut 意义不变的情况下更新，否则新增。</li>
<li>动态 Shortcuts 在 BackUp 恢复后不可以直接恢复，考虑适时新增或更新已有的 Shortcuts<br><strong>除了以上这些外，个人觉得还有几点需要遵守：</strong></li>
<li>如何更好的删除(废弃)老的 Shortcut<br>这里主要考虑到删除老的 Shortcut，可能会影响已经固定的 Shortcut。<br>对于静态 Shortcuts，直接删除配置文件中对应的 Shortcut 即可，系统桌面会将已固定的该 Shortcut 置灰，点击会提示 shortcutDisabledMessage。<br>对于动态 Shortcuts 建议通过禁用的方式而不是直接删除的方式，因为已经删除的动态 Shortcut 如果被固定了依然是可用的，所以希望该入口不可用最好的方式是禁用。</li>
<li>始终设置shortcutDisabledMessage<br>根据上面的介绍废弃老的 Shortcut 较好的方式是禁用，通过自定义shortcutDisabledMessage去更友好的提示用户。</li>
<li>动态添加 Shortcut 前需要判断 API 版本不小于 25<br>否则在低版本会报 ClassNotFoundException 异常。</li>
</ol>
<h3 id="7-一些问题"><a href="#7-一些问题" class="headerlink" title="7. 一些问题"></a>7. 一些问题</h3><h4 id="7-1-LongLabel-和-ShortLabel"><a href="#7-1-LongLabel-和-ShortLabel" class="headerlink" title="7.1 LongLabel 和 ShortLabel"></a>7.1 LongLabel 和 ShortLabel</h4><p>LongLabel和ShortLabel的含义，官方 API 文档解释的并不是很清楚。<br>在 Nexus 6 上测试，当 LongLabel 长度大于 17 个小写字符时，会显示 ShortLabel，而不是 LongLabel。这里的界限长度跟大小写、空格都有关，应该是受限于桌面 Shortcuts 列表 Item 的宽度！</p>
<h4 id="7-2-Shortcut-添加、修改、点击无效"><a href="#7-2-Shortcut-添加、修改、点击无效" class="headerlink" title="7.2 Shortcut 添加、修改、点击无效"></a>7.2 Shortcut 添加、修改、点击无效</h4><p>可能原因：  </p>
<ol>
<li>shortcutId 被覆盖<br>shortcutId 是唯一标识，相同 shortcutId 会被覆盖。  </li>
<li>intent 不对<br>intent 必须设置 android:action 属性，同时目标 Activity 必须有效即已在 Manifest 中声明。  </li>
<li>后台 App 有频率限制<br>当应该完全退到后台(无 Activity 或 Service 在前台时)，其操作 Shortcut(包括添加、删除、修改) 的频率是受限的。可通过isRateLimitingActive()查询是否已受限，true表示已受限。<br>若已受限，可通过开发者选项中“重置 ShortcutManager 调用频率限制”或命令行<code>adb shell cmd shortcut reset-throttling [ --user USER-ID ]</code>解决。  </li>
<li>Shortcut 个数限制<br>虽然官方文档介绍静态和动态 Shortcut 总和不能超过 5 个，通过getMaxShortcutCountPerActivity()得到的也是 5，但实际测试下来是不超过4个！即静态和动态shortcuts加起来总数最多是五个.<br>当我们尝试添加第六个shortcut时, 应用会抛出异常:<br> <code>java.lang.IllegalArgumentException: Max number of dynamic shortcuts exceeded.</code><br>虽然总数限制是5个, 但是当我正好有5个(2个静态 + 3个动态)的时候, 长按只显示了4个shortcuts.</li>
</ol>
<p><img src="http://obbu6r1mi.bkt.clouddn.com/ocnyang/android-7.1-app-shortcuts-5.png" alt="android-7.1-app-shortcuts数量的限制">  </p>
<h4 id="7-3-getIntents-有-Bug"><a href="#7-3-getIntents-有-Bug" class="headerlink" title="7.3 getIntents() 有 Bug"></a>7.3 getIntents() 有 Bug</h4><p>从 <a href="https://android.googlesource.com/platform/frameworks/base/+/android-7.1.0_r7/core/java/android/content/pm/ShortcutInfo.java#1170" target="_blank" rel="external">getIntents()</a> 实现 中可以看出未做mIntents是否为 null 及 empty 的判断，在 null 时会出现：  </p>
<pre><code>java.lang.NullPointerException: Attempt to get length of null array
</code></pre><p>的异常。</p>
<h3 id="8-三方桌面支持-Shortcuts——LauncherApps"><a href="#8-三方桌面支持-Shortcuts——LauncherApps" class="headerlink" title="8. 三方桌面支持 Shortcuts——LauncherApps"></a>8. 三方桌面支持 Shortcuts——LauncherApps</h3><p>如果三方桌面希望支持这个特性，请参考 <a href="https://developer.android.com/reference/android/content/pm/LauncherApps.html" target="_blank" rel="external">LauncherApps API</a> 介绍，不过只有系统默认桌面才有权限得到其他 <a href="http://ocnyang.com/">App Shortcuts</a> 信息。  </p>
<p>可通过hasShortcutHostPermission()查看是否拥有权限，如果没有权限，会报如下异常：  </p>
<pre><code>java.lang.RuntimeException: Unable to start activity ComponentInfo{com.xx/com.xx.XXActivity}: 
java.lang.SecurityException: Caller can&apos;t access shortcut information
   at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:2665)
   at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:2726)
</code></pre><p>通过getShortcuts API 获取到所有 Shortcuts 信息。</p>
<blockquote>
<p>参考:<br>App Shortcuts的官方文档: <a href="https://developer.android.com/preview/shortcuts.html" target="_blank" rel="external">App Shortcuts</a><br><a href="https://catinean.com/2016/10/20/exploring-android-nougat-7-1-app-shortcuts/" target="_blank" rel="external">Exploring Android Nougat 7.1 App Shortcuts</a></p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://ocnyang.com/2016/11/11/Palette/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="OCN.Yang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/ocnyang.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="杨欧神/OCN.Yang">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/11/Palette/" itemprop="url">
                  使用Palette抽取Bitmap主色调
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-11-11T17:03:15+08:00">
                2016-11-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android教程系列/" itemprop="url" rel="index">
                    <span itemprop="name">Android教程系列</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2016/11/11/Palette/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/11/11/Palette/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2016/11/11/Palette/" class="leancloud_visitors" data-flag-title="使用Palette抽取Bitmap主色调">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="使用Palette抽取Bitmap主色调"><a href="#使用Palette抽取Bitmap主色调" class="headerlink" title="使用Palette抽取Bitmap主色调"></a>使用Palette抽取Bitmap主色调</h1><p>一些Support库随着<a href="http://ocnyang.com/">Android Lollipop</a>的发布而诞生了，其中就有Palette。这个库可以让你很轻松地从一幅图中抽取特征颜色，这在你希望界面的颜色风格适应指定图片时非常有用，它还会提供与指定颜色相搭配的字体颜色。  </p>
<h2 id="关于Palette"><a href="#关于Palette" class="headerlink" title="关于Palette"></a>关于Palette</h2><p>Palette顾名思义调色板， Palette的作用是可以从图像中提取图片的颜色。我们可以把提取的颜色融入到App UI中，可以使UI风格更加美观融洽。有些时候Palette显得非常好用，比如我们可以提取到的突出的色值设置为Toolbar，标题，状态栏的颜色等，可以使我们的整个界面色调统一，效果非常好看。  </p>
<h2 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h2><h3 id="导包"><a href="#导包" class="headerlink" title="导包"></a>导包</h3><p>你需要在工程下的build.gradle里添加依赖才可以使用Palette，像如下代码所示：  </p>
<pre><code>dependencies {
  compile &apos;com.android.support:palette-v7:21.0.0&apos;
}
</code></pre><h3 id="生成Palette"><a href="#生成Palette" class="headerlink" title="生成Palette"></a>生成Palette</h3><p>生成一幅图像的Palette有一下几种方法：  </p>
<pre><code>// Synchronous methods.同步方法--------------------------------
// 这些应该在访问底层图像加载线程时使用。
// 方法1：使用默认16种颜色种类的调色板大小。
Palette p = Palette.generate(bitmap);
// 方法2：允许指定调色板的颜色种类的值，这里为24.
Palette p = Palette.generate(bitmap, 24);


// Asynchronous methods.异步方法--------------------------------
// 这是快速的集成路径，在内部使用AsyncTask等，不一定是最好的方式。
// 方法3：
Palette.generateAsync(bitmap, new Palette.PaletteAsyncListener() {
    @Override
    public void onGenerated(Palette palette) {
       // Here&apos;s your generated palette 这是你生成的调色板
    }
});
// 方法4：
Palette.generateAsync(bitmap, 24, new Palette.PaletteAsyncListener() {
    @Override
    public void onGenerated(Palette palette) {
       // Here&apos;s your generated palette
    }
});  
</code></pre><blockquote>
<p><strong>同步方法</strong>。由于他们很可能会比较耗时（在分析大图片或者所需颜色较多时），所以它们不应该在主线程中执行。你应该先在别的线程中使用这两个函数进行解析，解析成功之后再使用。<br><strong>异步方法</strong>。有时候你不会在加载图片的线程（非主线程）中使用解析出的颜色，所以Palette提供了异步方法，他们与之前的函数的区别就是需要传入PaletteAsyncListener，提供在图片解析完成后的回调函数。  </p>
</blockquote>
<p><strong>PaletteAsyncListener的实现</strong>是非常简单的（参考下面这几行代码），它只要重写onGenerated就好了。如此一来你就可以在任何需要的时候使用这两个函数创建Palette。</p>
<pre><code>Palette.PaletteAsyncListener listener = new Palette.PaletteAsyncListener() {
  public void onGenerated(Palette palette) {
    // 使用Palette对象，获取解析出的颜色
  }
}
</code></pre><h3 id="提取出的颜色"><a href="#提取出的颜色" class="headerlink" title="提取出的颜色"></a>提取出的颜色</h3><p>Palette默认会解析出图像的16种特征颜色种类，但是这六种颜色是你最经常用到的：  </p>
<ul>
<li>vibrant(鲜艳色)</li>
<li>dark vibrant(鲜艳色中的暗色)</li>
<li>light vibrant(鲜艳色中的亮色)</li>
<li>muted(柔和色)</li>
<li>dark muted(柔和色中的暗色)</li>
<li>light muted(柔和色中的亮色)</li>
</ul>
<p>借一张别人的图，给大家一种更直观的感受。  </p>
<p><img src="http://obbu6r1mi.bkt.clouddn.com/Palette/20150827183303088.png" alt="Palette解析六个主颜色">  </p>
<h3 id="获取提取的颜色"><a href="#获取提取的颜色" class="headerlink" title="获取提取的颜色"></a>获取提取的颜色</h3><p>你获取Palette对象之后，可以通过以下这些内置getter函数直接获取这六个颜色。你需要传入默认颜色防止Palette无法解析到指定颜色种类，返回的类型是24位RGB颜色数值。</p>
<pre><code>Palette palette = Palette.generate(myBitmap);
int vibrant = palette.getVibrantColor(0x000000);
int vibrantLight = palette.getLightVibrantColor(0x000000);
int vibrantDark = palette.getDarkVibrantColor(0x000000);
int muted = palette.getMutedColor(0x000000);
int mutedLight = palette.getLightMutedColor(0x000000);
int mutedDark = palette.getDarkMutedColor(0x000000);

//独特的一种
getDominantColor(int defaultColor)
//返回从调色板中占主导地位的样本的颜色，为RGB包装INT。
</code></pre><h3 id="获取Swatch"><a href="#获取Swatch" class="headerlink" title="获取Swatch"></a>获取Swatch</h3><p>你也可以选择先获取Swatch对象，然后再通过Swatch提供的方法获取颜色的相关信息：  </p>
<pre><code>Palette.Swatch s = p.getVibrantSwatch();       //获取到充满活力的这种色调
Palette.Swatch s = p.getDarkVibrantSwatch();    //获取充满活力的黑
Palette.Swatch s = p.getLightVibrantSwatch();   //获取充满活力的亮
Palette.Swatch s = p.getMutedSwatch();           //获取柔和的色调
Palette.Swatch s = p.getDarkMutedSwatch();      //获取柔和的黑
Palette.Swatch s = p.getLightMutedSwatch();    //获取柔和的亮

//独特的一种
getDominantSwatch()
//返回从调色板中占主导地位的样本。
</code></pre><blockquote>
<p>注意：<a href="http://ocnyang.com/">getVibrantSwatch()</a>可能会返回一个null值，所以在使用前检查一下是必须的。<code>if (swatch != null) {}</code>  </p>
</blockquote>
<p>Palette解析出的颜色都来自于对应的Swatch，在Swatch里面含有很多关于对应颜色的有用信息。你可以从Swatch中获取RGB颜色值、HSL颜色向量、对应颜色在图像中所占的比例、与对应颜色搭配的标题字体颜色和正文字体颜色（这两个颜色和对应颜色的对比值是处理好的，你不必再去操心）。 </p>
<p><strong>swatch对象对应的颜色方法：</strong>  </p>
<pre><code>getPopulation(): 像素的数量
getRgb(): RGB颜色
getHsl(): HSL颜色
getBodyTextColor(): 用于内容正文文本的颜色
getTitleTextColor(): 标题文本的颜色
</code></pre><p>Palette只为六种主颜色种类Swatch提供了getter，如果你要使用其他颜色种类的Swatch（一共有16种颜色种类），你需要手动获取它。调用getSwatchs()会返回一个列表，里面有所有获取到的Swatch。</p>
<pre><code>List&lt;Palette.Swatch&gt; swatches = palette.getSwatches();
</code></pre><p>这里是一个Palette获取所有Swatch的例子，里面展示了它们分别在图像中所占的比例：</p>
<p><img src="http://obbu6r1mi.bkt.clouddn.com/Palette/20150827183359416.png" alt="">  </p>
<h3 id="关于颜色种类的值size"><a href="#关于颜色种类的值size" class="headerlink" title="关于颜色种类的值size"></a>关于颜色种类的值size</h3><p>在上面生成Palette的时候，你可能注意到了可以设置Palette的size。size越大，花费的时间越长，而越小，可以选择的色彩也越小。最佳的选择是根据image的用途：  </p>
<ul>
<li>头像之类的，size最好在24-32之间；  </li>
<li>风景大图之类的，size差不多在8-16；  </li>
<li>默认是16.  </li>
</ul>
<h2 id="Palette实例"><a href="#Palette实例" class="headerlink" title="Palette实例"></a>Palette实例</h2><p>Palette经常用于和ViewPager，Fragment搭配使用，当我们的Pager切换时伴随着Fragment的变化，而Fragment里的内容一般是不同的，所以每个Fragment里的一般视觉效果也是不同的，所以我们可以用Palette来去提取Fragment中的主色调，把这个主色调用于整体的UI风格。</p>
<p><img src="http://obbu6r1mi.bkt.clouddn.com/Palette/tmpdir__16_6_28_18_41_09.gif" alt="效果图">  </p>
<p>这个例子可以参考这篇博客：<a href="http://www.jianshu.com/p/9fcf316031ba" target="_blank" rel="external">http://www.jianshu.com/p/9fcf316031ba</a><br>Demo的地址：<a href="https://github.com/loonggg/MaterialDesignDemo" target="_blank" rel="external">https://github.com/loonggg/MaterialDesignDemo</a>  </p>
<p>另外一个例子：  </p>
<p><img src="http://obbu6r1mi.bkt.clouddn.com/Palette/cd389848270623564.png" alt=""> <img src="http://obbu6r1mi.bkt.clouddn.com/Palette/cd389848270623565.png" alt="">  </p>
<p>详情参考这篇博客：<a href="http://www.itdadao.com/articles/c15a485862p0.html" target="_blank" rel="external">http://www.itdadao.com/articles/c15a485862p0.html</a><br>Demo下载地址：<a href="http://download.csdn.net/detail/breeze_wf/9273313" target="_blank" rel="external">http://download.csdn.net/detail/breeze_wf/9273313</a>  </p>
<blockquote>
<p>关于更多Palette的详细用法，可以查看<a href="https://developer.android.com/reference/android/support/v7/graphics/Palette.html" target="_blank" rel="external">官方API文档</a>。</p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://ocnyang.com/2016/11/03/EffectiveJava/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="OCN.Yang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/ocnyang.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="杨欧神/OCN.Yang">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/11/03/EffectiveJava/" itemprop="url">
                  《Effective Java》笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-11-03T09:03:15+08:00">
                2016-11-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android教程系列/" itemprop="url" rel="index">
                    <span itemprop="name">Android教程系列</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2016/11/03/EffectiveJava/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/11/03/EffectiveJava/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2016/11/03/EffectiveJava/" class="leancloud_visitors" data-flag-title="《Effective Java》笔记">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="《Effective-Java》笔记"><a href="#《Effective-Java》笔记" class="headerlink" title="《Effective Java》笔记"></a>《Effective Java》笔记</h1><h2 id="对象的创建与销毁"><a href="#对象的创建与销毁" class="headerlink" title="对象的创建与销毁"></a>对象的创建与销毁</h2><ul>
<li>Item 1: 使用static工厂方法，而不是构造函数创建对象：仅仅是创建对象的方法，并非Factory Pattern<ul>
<li>优点<ul>
<li>命名、接口理解更高效，通过工厂方法的函数名，而不是参数列表来表达其语义</li>
<li>Instance control，并非每次调用都会创建新对象，可以使用预先创建好的对象，或者做对象缓存；便于实现单例；或不可实例化的类；对于immutable的对象来说，使得用<code>==</code>判等符合语义，且更高效；</li>
<li>工厂方法能够返回任何返回类型的子类对象，甚至是私有实现；使得开发模块之间通过接口耦合，降低耦合度；而接口的实现也将更加灵活；接口不能有static方法，通常做法是为其再创建一个工厂方法类，如Collection与Collections；</li>
<li>Read More: Service Provider Framework</li>
</ul>
</li>
<li>缺点<ul>
<li>仅有static工厂方法，没有public/protected构造函数的类将无法被继承；见仁见智，这一方面也迫使开发者倾向于组合而非继承；</li>
<li>Javadoc中不能和其他static方法区分开，没有构造函数的集中显示优点；但可以通过公约的命名规则来改善；</li>
</ul>
</li>
<li>小结<br>static工厂方法和public构造函数均有其优缺点，在编码过程中，可以先考虑一下工厂方法是否合适，再进行选择。</li>
</ul>
</li>
<li>Item 2: 使用当构造函数的参数较多，尤其是其中还有部分是可选参数时，使用Builder模式<ul>
<li>以往的方法<ul>
<li>Telescoping constructor：针对可选参数，从0个到最多个，依次编写一个构造函数，它们按照参数数量由少到多逐层调用，最终调用到完整参数的构造函数；代码冗余，有时还得传递无意义参数，而且容易导致使用过程中出隐蔽的bug；</li>
<li>JavaBeans Pattern：灵活，但是缺乏安全性，有状态不一致问题，线程安全问题；</li>
</ul>
</li>
<li>Builder Pattern<ul>
<li>代码灵活简洁；具备安全性；</li>
<li>immutable</li>
<li>参数检查：最好放在要build的对象的构造函数中，而非builder的构建过程中</li>
<li>支持多个field以varargs的方式设置（每个函数只能有一个varargs）</li>
<li>一个builder可以build多个对象</li>
<li>Builder结合泛型，实现Abstract Factory Pattern</li>
<li>传统的抽象工厂模式，是用Class类实现的，然而其有缺点：newInstance调用总是去调用无参数构造函数，不能保证存在；newInstance方法会抛出所有无参数构造函数中的异常，而且不会被编译期的异常检查机制覆盖；可能会导致运行时异常，而非编译期错误；</li>
</ul>
</li>
<li>小结<br>Builder模式在简单地类（参数较少，例如4个以下）中，优势并不明显，但是需要予以考虑，尤其是当参数可能会变多时，有可选参数时更是如此。</li>
</ul>
</li>
<li><p>Item 3: 单例模式！<br>不管以哪种形式实现单例模式，它们的核心原理都是将构造函数私有化，并且通过静态方法获取一个唯一的实例，在这个获取的过程中你必须保证线程安全、反序列化导致重新生成实例对象等问题，该模式简单，但使用率较高。</p>
<ul>
<li>double-check-locking  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> RestAdapter sRestAdapter = <span class="keyword">null</span>;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RestAdapter <span class="title">provideRestAdapter</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (sRestAdapter == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">synchronized</span> (RestProvider.class) &#123;</div><div class="line">            <span class="keyword">if</span> (sRestAdapter == <span class="keyword">null</span>) &#123;</div><div class="line">                sRestAdapter = <span class="keyword">new</span> RestAdapter();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> sRestAdapter;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>DCL可能会失效，因为指令重排可能导致同步解除后，对象初始化不完全就被其他线程获取；使用volatile关键字修饰对象，或者使用static SingletonHolder来避免该问题（后者JLS推荐）；</p>
<ul>
<li>class的static代码：一个类只有在被使用时才会初始化，而类初始化过程是非并行的，这些都由JLS能保证</li>
<li>用enum实现单例</li>
<li>还存在反射安全性问题：利用反射，可以访问私有方法，可通过加一个控制变量，该变量在getInstance函数中设置，如果不是从getInstance调用构造函数，则抛出异常；</li>
</ul>
</li>
<li>Item 4: 将构造函数私有化，使得不能从类外创建实例，同时也能禁止类被继承<br>util类可能不希望被实例化，有其需求</li>
<li>Item 5: 避免创建不必要的对象<ul>
<li>提高性能：创建对象需要时间、空间，“重量级”对象尤甚；immutable的对象也应该避免重复创建，例如String；</li>
<li>避免auto-boxing</li>
<li>但是因此而故意不创建必要的对象是错误的，使用object pool通常也是没必要的</li>
<li>lazy initialize也不是特别必要，除非使用场景很少且很重量级</li>
<li>Map#keySet方法，每次调用返回的是同一个Set对象，如果修改了返回的set，其他使用的代码可能会产生bug</li>
<li>需要defensive copying的时候，如果没有创建一个新对象，将导致很隐藏的Bug</li>
</ul>
</li>
<li>Item 6: 不再使用的对象一定要解除引用，避免memory leak<ul>
<li>例如，用数组实现一个栈，pop的时候，如果仅仅是移动下标，没有把pop出栈的数组位置引用解除，将发生内存泄漏</li>
<li>程序发生错误之后，应该尽快把错误抛出，而不是以错误的状态继续运行，否则可能导致更大的问题</li>
<li>通过把变量（引用）置为null不是最好的实现方式，只有在极端情况下才需要这样；好的办法是通过作用域来使得变量的引用过期，所以尽量缩小变量的作用域是很好的实践；注意，在Dalvik虚拟机中，存在一个细微的bug，可能会导致内存泄漏，<a href="MemoryLeak.md">详见</a></li>
<li>当一个类管理了一块内存，用于保存其他对象（数据）时，例如用数组实现的栈，底层通过一个数组来管理数据，但是数组的大小不等于有效数据的大小，GC器却并不知道这件事，所以这时候，需要对其管理的数据对象进行null解引用</li>
<li>当一个类管理了一块内存，用于保存其他对象（数据）时，程序员应该保持高度警惕，避免出现内存泄漏，一旦数据无效之后，需要立即解除引用</li>
<li>实现缓存的时候也很容易导致内存泄漏，放进缓存的对象一定要有换出机制，或者通过弱引用来进行引用</li>
<li>listner和callback也有可能导致内存泄漏，最好使用弱引用来进行引用，使得其可以被GC</li>
</ul>
</li>
<li>Item 7: 不要使用finalize方法<ul>
<li>finalize方法不同于C++的析构函数，不是用来释放资源的好地方</li>
<li>finalize方法执行并不及时，其执行线程优先级很低，而当对象unreachable之后，需要执行finalize方法之后才能释放，所以会导致对象生存周期变长，甚至根本不会释放</li>
<li>finalize方法的执行并不保证执行成功/完成</li>
<li>使用finalize时，性能会严重下降</li>
<li>finalize存在的意义<ul>
<li>充当“safety net”的角色，避免对象的使用者忘记调用显式termination方法，尽管finalize方法的执行时间没有保证，但是晚释放资源好过不释放资源；此处输出log警告有利于排查bug</li>
<li>用于释放native peer，但是当native peer持有必须要释放的资源时，应该定义显式termination方法</li>
</ul>
</li>
<li>子类finalize方法并不会自动调用父类finalize方法（和构造函数不同），为了避免子类不手动调用父类的finalize方法导致父类的资源未被释放，当需要使用finalize时，使用finalizer guardian比较好：<ul>
<li>定义一个私有的匿名Object子类对象，重写其finalize方法，在其中进行父类要做的工作</li>
<li>因为当父类对象被回收时，finalizer guardian也会被回收，它的finalize方法就一定会被触发</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Object的方法"><a href="#Object的方法" class="headerlink" title="Object的方法"></a>Object的方法</h2><p>尽管Object不是抽象类，但是其定义的非final方法设计的时候都是希望被重写的，finalize除外。</p>
<ul>
<li>Item 8: 当重写equals方法时，遵循其语义<ul>
<li>能不重写equals时就不要重写<ul>
<li>当对象表达的不是值，而是可变的状态时</li>
<li>对象不需要使用判等时</li>
<li>父类已重写，且满足子类语义</li>
</ul>
</li>
<li>当需要判等，且继承实现无法满足语义时，需要重写（通常是“value class”，或immutable对象）</li>
<li>当用作map的key时</li>
<li>重写equals时需要遵循的语义<ul>
<li>Reflexive（自反性）: x.equals(x)必须返回true（x不为null）</li>
<li>Symmetric（对称性）: x.equals(y) == y.equals(x)</li>
<li>Transitive（传递性）: x.equals(y) &amp;&amp; y.equals(z) ==&gt; x.equals(z)</li>
<li>Consistent（一致性）: 当对象未发生改变时，多次调用应该返回同一结果</li>
<li>x.equals(null)必须返回false</li>
</ul>
</li>
<li>实现建议<ul>
<li>先用==检查是否引用同一对象，提高性能</li>
<li>用instanceof再检查是否同一类型</li>
<li>再强制转换为正确的类型</li>
<li>再对各个域进行equals检查，遵循同样的规则</li>
<li>确认其语义正确，编写测例</li>
<li>重写equals时，同时也重写hashCode</li>
<li>！重写equals方法，传入的参数是Object</li>
</ul>
</li>
</ul>
</li>
<li>Item 9: 重写equals时也重写hashCode函数<ul>
<li>避免在基于hash的集合中使用时出错</li>
<li>语义<ul>
<li>一致性</li>
<li>当两个对象equals返回true时，hashCode方法的返回值也要相同</li>
</ul>
</li>
<li>hashCode的计算方式<ul>
<li>要求：equals的两个对象hashCode一样，但是不equals的对象hashCode不一样</li>
<li>取一个素数，例如17，result = 17</li>
<li>对每一个关心的field（在equals中参与判断的field），记为f，将其转换为一个int，记为c</li>
<li>boolean: f ? 1 : 0</li>
<li>byte/char/short/int: (int) f</li>
<li>long: (int) (f ^ (f &gt;&gt; 32))</li>
<li>float: Float.floatToIntBits(f)</li>
<li>double: Double.doubleToLongBits(f)，再按照long处理</li>
<li>Object: f == null ? 0 : f.hashCode()</li>
<li>array: 先计算每个元素的hashCode，再按照int处理</li>
<li>对每个field计算的c，result = 31 * result + c</li>
<li>返回result</li>
<li>编写测例</li>
</ul>
</li>
<li>计算hashCode时，不重要的field（未参与equals判断）不要参与计算</li>
</ul>
</li>
<li>Item 10: 重写toString()方法<ul>
<li>增加可读性，简洁、可读、具有信息量</li>
</ul>
</li>
<li>Item 11: 慎重重写clone方法<ul>
<li>Cloneable接口是一个mixin interface，用于表明一个对象可以被clone</li>
<li>Contract<ul>
<li>x.clone() != x</li>
<li>x.clone().getClass() ==  x.getClass()：要求太弱，当一个非final类重写clone方法的时候，创建的对象一定要通过super.clone()来获得，所有父类都遵循同样的原则，如此最终通过Object.clone()创建对象，能保证创建的是正确的类实例。而这一点很难保证。</li>
<li>x.clone().equals(x)</li>
<li>不调用构造函数：要求太强，一般都会在clone函数里面调用</li>
</ul>
</li>
<li>对于成员变量都是primitive type的类，直接调用super.clone()，然后cast为自己的类型即可（重写时允许返回被重写类返回类型的子类，便于使用方，不必每次cast）</li>
<li>成员变量包含对象（包括primitive type数组），可以通过递归调用成员的clone方法并赋值来实现</li>
<li>然而上述方式违背了final的使用协议，final成员不允许再次赋值，然而clone方法里面必须要对其赋值，则无法使用final保证不可变性了</li>
<li>递归调用成员的clone方法也会存在性能问题，对HashTable递归调用深拷贝也可能导致StackOverFlow（可以通过遍历添加来避免）</li>
<li>优雅的方式是通过super.clone()创建对象，然后为成员变量设置相同的值，而不是简单地递归调用成员的clone方法</li>
<li>和构造函数一样，在clone的过程中，不能调用non final的方法，如果调用虚函数，那么该函数会优先执行，而此时被clone的对象状态还未完成clone/construct，会导致corruption。因此上一条中提及的“设置相同的值”所调用的方法，要是final或者private。</li>
<li>重载类的clone方法可以省略异常表的定义，如果重写时把可见性改为public，则应该省略，便于使用；如果设计为应该被继承，则应该重写得和Object的一样，且不应该实现Cloneable接口；多线程问题也需要考虑；</li>
<li>要实现clone方法的类，都应该实现Cloneable接口，同时把clone方法可见性设为public，返回类型为自己，应该调用super.clone()来创建对象，然后手动设置每个域的值</li>
<li>clone方法太过复杂，如果不实现Cloneable接口，也可以通过别的方式实现copy功能，或者不提供copy功能，immutable提供copy功能是无意义的</li>
<li>提供拷贝构造函数，或者拷贝工厂方法，而且此种方法更加推荐，但也有其不足</li>
<li>设计用来被继承的类时，如果不实现一个正确高效的clone重写，那么其子类也将无法实现正确高效的clone功能</li>
</ul>
</li>
<li>Item 12: 当对象自然有序时，实现Comparable接口<ul>
<li>实现Comparable接口可以利用其有序性特点，提高集合使用/搜索/排序的性能</li>
<li>Contact<ul>
<li>sgn(x.compareTo(y)) == - sgn(y.compareTo(x))，当类型不对时，应该抛出ClassCastException，抛出异常的行为应该是一致的</li>
<li>transitive: x.compareTo(y) &gt; 0 &amp;&amp; y.compareTo(z) &gt; 0 ==&gt; x.compareTo(z) &gt; 0</li>
<li>x.compareTo(y) == 0 ==&gt; sgn(x.compareTo(z)) == sgn(y.compareTo(z))</li>
<li>建议，但非必须：与equals保持一致，即 x.compareTo(y) == 0 ==&gt; x.equals(y)，如果不一致，需要在文档中明确指出</li>
</ul>
</li>
<li>TreeSet, TreeMap等使用的就是有序保存，而HashSet, HashMap则是通过equals + hashCode保存</li>
<li>当要为一个实现了Comparable接口的类增加成员变量时，不要通过继承来实现，而是使用组合，并提供原有对象的访问方法，以保持对Contract的遵循</li>
<li>实现细节<ul>
<li>优先比较重要的域</li>
<li>谨慎使用返回差值的方式，有可能会溢出</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Classes-and-Interfaces"><a href="#Classes-and-Interfaces" class="headerlink" title="Classes and Interfaces"></a>Classes and Interfaces</h2><ul>
<li>Item 13: 最小化类、成员的可见性<ul>
<li>封装（隐藏）：公开的接口需要暴露，而接口的实现则需要隐藏，使得接口与实现解耦，降低模块耦合度，增加可测试性、稳定性、可维护性、可优化性、可修改性</li>
<li>如果一个类只对一个类可见，则应该将其定义为私有的内部类，而没必要public的类都应该定义为package private</li>
<li>为了便于测试，可以适当放松可见性，但也只应该改为package private，不能更高</li>
<li>成员不能是非private的，尤其是可变的对象。一旦外部可访问，将失去对其内容的控制能力，而且会有多线程问题</li>
<li>暴露的常量也不能是可变的对象，否则public static final也将失去其意义，final成员无法改变其指向，但其指向的对象却是可变的（immutable的对象除外），长度非0的数组同样也是有问题的，可以考虑每次访问时创建拷贝，或者使用<code>Collections.unmodifiableList(Arrays.asList(arr))</code></li>
</ul>
</li>
<li>Item 14: public class中，使用accessor method而非public field<ul>
<li>后者外部可以直接访问，失去了安全性</li>
<li>package private或者private则可以不必这样</li>
<li>把immutable的field置为public勉强可以接受，mutable的成员一定不能置为public</li>
</ul>
</li>
<li>Item 15: 最小化可变性<ul>
<li>不提供可以改变本对象状态的方法</li>
<li>保证类不可被继承</li>
<li>使用final field</li>
<li>使用private field</li>
<li>在构造函数、accessor中，对mutable field使用defensive copy</li>
<li>实现建议<ul>
<li>操作函数，例如BigInteger的add方法，不是static的，但也不能改变本对象的状态，则使用functional的方式，返回一个新的对象，其状态是本对象修改之后的状态</li>
<li>如此实现的immutable对象生来就是线程安全的，无需同步操作，但应该鼓励共用实例，避免创建过多重复的对象</li>
<li>正确实现的immutable对象也不需要clone, copy方法；可以适当引入Object cache；</li>
</ul>
</li>
<li>劣势<ul>
<li>每一个值都需要一个对象，调用改变状态的方法而创建一个新的对象，尤其是它是重量级的，开销会变大；连续调用这样的方法，影响更大；</li>
<li>为常用的多次操作组合提供一个方法</li>
</ul>
</li>
<li>其他<ul>
<li>保证class无法被继承，除了声明为final外，还可以将默认构造函数声明为private或package private，然后提供public static工厂方法</li>
<li>使用public static工厂方法，具体实现类可以有多个，还能进行object cache</li>
<li>当实现Serializable接口是，一定要实现readObject/readResolve方法，或者使用ObjectOutputStream.writeUnshared/ObjectInputStream.readUnshared</li>
</ul>
</li>
<li>小结<ul>
<li>除非有很好的理由让一个Class mutable，否则应该使其immutable</li>
<li>如果非要mutable，也应尽可能限制其可变性</li>
</ul>
</li>
</ul>
</li>
<li>Item 16: Favor composition (and forwarding) over inheritance<ul>
<li>跨包继承、继承不是被设计为应该被继承的实现类，是一件很危险的事情，继承接口、继承抽象类，当然是没问题的</li>
<li>如果子类的功能依赖于父类的实现细节，那么一旦父类发生变化，子类将有可能出现Bug，即便代码都没有修改；而设计为应被继承的类，在修改后，是应该有文档说明的，子类开发者既可以得知，也可以知道如何修改</li>
<li>例子：统计HashSet添加元素的次数<ul>
<li>用继承方式，重写add，addAll，在其中计数，这就不对，因为HashSet内部的addAll是通过调用add实现的</li>
<li>但是通过不重写addAll也只不对的，以后有可能HashSet的实现就变了</li>
<li>在重写中重新实现一遍父类的逻辑也是行不通的，因为这可能会导致性能问题、bug等，而且有些功能不访问私有成员也是无法实现的</li>
<li>还有一个原因就是父类的实现中，可能会增加方法，改变其行为，而这一点，在子类中是无法控制的</li>
</ul>
</li>
<li>而通过组合的方式，将不会有这些问题，把另一个类的对象声明为私有成员，外部将无法访问它，自己也能在转发（forwarding）过程中执行拦截操作，也不必依赖其实现细节，这种组合、转发的实现被称为wrapper，或者Decorator pattern，或者delegation（严格来说不是代理，代理一般wrapper对象都需要把自己传入到被wrap的对象方法中？）</li>
<li>缺点<ul>
<li>不适用于callback frameworks？</li>
</ul>
</li>
<li>继承应该在is-a的场景中使用</li>
<li>继承除了会继承父类的API功能，也会继承父类的设计缺陷，而组合则可以隐藏成员类的设计缺陷</li>
</ul>
</li>
<li>Item 17: Design and document for inheritance or else prohibit it<ul>
<li>一个类必须在文档中说明，每个可重写的方法，在该类的实现中的哪些地方会被调用（the class must document its self-use of overridable methods）。调用时机、顺序、结果产生的影响，包括多线程、初始化等情况。</li>
<li>被继承类应该通过谨慎选择protected的方法或成员，来提供一些hook，用于改变其内部的行为，例如java.util.AbstractList::removeRange。</li>
<li>The only way to test a class designed for inheritance is to write subclasses. 用于判断是否需要增加或者减少protected成员/方法，通常写3个子类就差不多了。</li>
<li>You must test your class by writing subclasses before you release it.</li>
<li>Constructors must not invoke overridable methods. 父类的构造函数比子类的构造函数先执行，而如果父类构造函数中调用了可重写的方法，那么就会导致子类的重写方法比子类的构造函数先执行，会导致corruption。</li>
<li>如果实现了Serializable/Cloneable接口，neither clone nor readObject may invoke an overridable method, directly or indirectly. 重写方法会在deserialized/fix the clone’s state之前执行。</li>
<li>如果实现了Serializable接口，readResolve/writeReplace必须是protected，而非private</li>
<li>designing a class for inheritance places substantial limitations on the class.</li>
<li>The best solution to this problem is to prohibit subclassing in classes that are not designed and documented to be safely subclassed. 声明为final class或者把构造函数私有化（提供public static工厂方法）。</li>
<li>如果确实想要允许继承，就应该为每个被自己使用的可重写方法都写好文档</li>
</ul>
</li>
<li>Item 18: Prefer interfaces to abstract classes<ul>
<li>Java类只允许单继承，接口可以多继承，使用接口定义类型，使得class hierarchy更加灵活</li>
<li>定义mixin（optional functionality to be “mixed in”）时使用interface是很方便的，需要增加此功能的类只需要implement该接口即可，而如果使用抽象类，则无法增加一个extends语句</li>
<li>接口允许构建没有hierarchy的类型系统</li>
<li>使用接口定义类型，可以使得item 16中提到的wrapper模式更加安全、强大，</li>
<li>skeletal implementation：该类为abstract，把必须由client实现的方法设为abstract，可以有默认实现的则提供默认实现</li>
<li>simulated multiple inheritance：通过实现定义的接口，同时在内部实现一个匿名的skeletal implementation，将对对该接口的调用转发到匿名类中，起到“多继承”的效果</li>
<li>simple implementation：提供一个非抽象的接口实现类，提供一个最简单、能work的实现，也允许被继承</li>
<li>使用接口定义类型的缺点：不便于演进，一旦接口发布，如果想要增加功能（增加方法），则client将无法编译；而使用abstract class，则没有此问题，只需要提供默认实现即可</li>
<li>小结<ul>
<li>通过接口定义类型，可以允许多实现（多继承）</li>
<li>但是演进需求大于灵活性、功能性时，抽象类更合适</li>
<li>提供接口时，提供一个skeletal implementation，同时审慎考虑接口设计</li>
</ul>
</li>
</ul>
</li>
<li>Item 19: 仅仅用interface去定义一个类型，该接口应该有实现类，使用者通过接口引用，去调用接口的方法<ul>
<li>避免用接口去定义常量，应该用noninstantiable utility class去定义常量</li>
<li>相关常量的命名，通过公共前缀来实现分组</li>
</ul>
</li>
<li>Item 20: Prefer class hierarchies to tagged classes<ul>
<li>tagged class: 在内部定义一个tag变量，由其控制功能的转换</li>
<li>tag classes are verbose, error-prone, and inefficient</li>
<li>而class hierarchy，不同功能由不同子类实现，公共部分抽象为一个基类，也能反映出各个子类之间的关系</li>
</ul>
</li>
<li>Item 21: Use function objects to represent strategies<ul>
<li>只提供一个功能函数的类实例，没有成员变量，只需一个对象（单例），为其功能定义一个接口，则可以实现策略模式，把具体策略传入相应函数中，使用策略</li>
<li>具体的策略实例通常使用匿名类定义，调用使用该策略的方法时才予以创建/预先创建好之后每次将其传入</li>
</ul>
</li>
<li>Item 22: Favor static member classes over nonstatic<ul>
<li>有4种nested class：non-static member class; static member class(inner class); anonymous class; local class</li>
<li>static member class<ul>
<li>经常作为helper class，和外部类一起使用</li>
<li>如果nested class的生命周期独立于外部类存在，则必须定义为static member class，否则可能造成内存泄漏</li>
<li>private static member class用处一：表示（封装）外部类的一些成员，例如Map的Entry内部类。</li>
</ul>
</li>
<li>non-static member class<ul>
<li>将持有外部类实例的强引用，可以直接引用外部类的成员和方法</li>
<li>用处一：定义一个Adapter，使得外部内的实例，可以作为和外部类语义不同的实例来查看（访问），例如Collection的Iterator。</li>
<li>如果nested class不需要引用外部类的成员和方法，则一定要将其定义为static，避免空间/时间开销，避免内存泄漏</li>
</ul>
</li>
<li>anonymous class<ul>
<li>当在非static代码块内定义时，会持有外部类的引用，否则不会持有</li>
<li>限制</li>
<li>只能在被声明的地方进行实例化</li>
<li>无法进行instanceof测试</li>
<li>不能用匿名类实现多个接口</li>
<li>不能用匿名类继承一个类的同时实现接口</li>
<li>匿名类中新添加的方法无法在匿名类外部访问</li>
<li>不能有static成员</li>
<li>应该尽量保持简短</li>
<li>用处一：创建function object</li>
<li>用处二：创建process object，例如：Runnable, Thread, TimberTask</li>
<li>用处三：用于public static工厂方法，例如Collections类里面的一些工厂方法，很多是返回一个匿名的内部实现</li>
</ul>
</li>
<li>local class<ul>
<li>比较少用</li>
<li>是否static取决于其定义的上下文</li>
<li>可以在作用域内重复使用</li>
<li>不能有static成员</li>
<li>也应尽量保持简短</li>
</ul>
</li>
<li>小结<ul>
<li>四种nested class</li>
<li>如果nested class在整个外部类内都需要可见，或者定义代码太长，应使用member class</li>
<li>能static就一定要static，即便需要对外部类进行引用，对于生命周期独立于外部类的，也应该通过WeakReference进行引用，避免内存泄漏；至于生命周期和外部类一致的，则不必这样</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Generics"><a href="#Generics" class="headerlink" title="Generics"></a>Generics</h2><ul>
<li><p>Item 23: Don’t use raw types in new code</p>
<ul>
<li>Java泛型，例如<code>List&lt;E&gt;</code>，真正使用的时候都是<code>List&lt;String&gt;</code>等，把E替换为实际的类型</li>
<li>Java泛型从1.5引入，为了保持兼容性，实现的是伪泛型，类型参数信息在编译完成之后都会被擦除，其在运行时的类型都是raw type，类型参数保存的都是Object类型，<code>List&lt;E&gt;</code>的raw type就是<code>List</code></li>
<li>编译器在编译期通过类型参数，为读操作自动进行了类型强制转换，同时在写操作时自动进行了类型检查</li>
<li>如果使用raw type，那编译器就不会在写操作时进行类型检查了，写入错误的类型也不会报编译错误，那么在后续读操作进行强制类型转换时，将会导致转换失败，抛出异常</li>
<li>一旦错误发生，应该让它尽早被知道（抛出/捕获），编译期显然优于运行期</li>
<li><p><code>List</code>与<code>List&lt;Object&gt;</code>的区别</p>
<ul>
<li>前者不具备类型安全性，后者具备，例如以下代码<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Uses raw type (List) - fails at runtime!</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">  List&lt;String&gt; strings = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">  unsafeAdd(strings, <span class="keyword">new</span> Integer(<span class="number">42</span>));</div><div class="line">  String s = strings.get(<span class="number">0</span>); <span class="comment">// Compiler-generated cast</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unsafeAdd</span><span class="params">(List list, Object o)</span> </span>&#123;</div><div class="line">  list.add(o);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>不会报编译错误，但会给一个编译警告：<code>Test.java:10: warning: unchecked call to add(E) in raw type List list.add(o);</code>，而运行时则会发生错误。</p>
<ul>
<li>但如果使用<code>List&lt;Object&gt;</code>，即<code>unsageAdd</code>参数改为<code>List&lt;Object&gt; list, Object o</code>，则会报编译错误：<code>Test.java:5: unsafeAdd(List&lt;Object&gt;,Object) cannot be applied to (List&lt;String&gt;,Integer) unsafeAdd(strings, new Integer(42));</code>  </li>
<li>因为<code>List&lt;String&gt;</code>是<code>List</code>的子类，但却不是<code>List&lt;Object&gt;</code>的子类。  </li>
<li>并不是说这个场景应该使用<code>List&lt;Object&gt;</code>，这个场景应该使用<code>List&lt;String&gt;</code>，这里只是为了说明<code>List</code>和<code>List&lt;Object&gt;</code>是有区别的。</li>
</ul>
</li>
<li><p><code>List</code> v.s. <code>List&lt;?&gt;</code>（unbounded wildcard types），当不确定类型参数，或者说类型参数不重要时，也不应该使用raw type，而应该使用<code>List&lt;?&gt;</code></p>
<ul>
<li><p>任何参数化的List均是<code>List&lt;?&gt;</code>的子类，可以作为参数传入接受<code>List&lt;?&gt;</code>的函数，例如以下代码均是合法的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(List&lt;?&gt; list)</span> </span>&#123;</div><div class="line">  ...</div><div class="line">&#125;</div><div class="line"></div><div class="line">func(<span class="keyword">new</span> List&lt;Object&gt;());</div><div class="line">func(<span class="keyword">new</span> List&lt;Integer&gt;());</div><div class="line">func(<span class="keyword">new</span> List&lt;String&gt;());</div></pre></td></tr></table></figure>
</li>
<li><p>持有<code>List&lt;?&gt;</code>的引用后，并不能向其中加入任何元素，读取出来的元素也是<code>Object</code>类型，而不会被自动强转为任何类型。</p>
</li>
<li>如果<code>List&lt;?&gt;</code>的行为不能满足需求，可以考虑使用模板方法，或者<code>List&lt;E extends XXX&gt;</code>（bounded wildcard types）</li>
</ul>
</li>
<li>You must use raw types in class literals.<ul>
<li><code>List.class</code>, <code>String[].class</code>, and <code>int.class</code> are all legal, but <code>List&lt;String&gt;.class</code> and <code>List&lt;?&gt;.class</code> are not.</li>
</ul>
</li>
<li><p><code>instanceof</code>不支持泛型，以下用法是推荐的，但不应该将<code>o</code>强转为<code>List</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Legitimate use of raw type - instanceof operator</span></div><div class="line"><span class="keyword">if</span> (o <span class="keyword">instanceof</span> Set) &#123; <span class="comment">// Raw type</span></div><div class="line">  Set&lt;?&gt; m = (Set&lt;?&gt;) o; <span class="comment">// Wildcard type</span></div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>相关术语汇总<br><img src="http://obbu6r1mi.bkt.clouddn.com/ocnyangcom/java_generic_terms.png" alt="java_generic_terms.png"></p>
</li>
</ul>
</li>
<li>Item 24: Eliminate unchecked warnings<ul>
<li>当出现类型不安全的强制转换时（一般都是涉及泛型，raw type），编译器会给出警告，首先要做的是尽量消除不安全的转换，消除警告</li>
<li>实在无法消除/确定不会导致运行时的<code>ClassCastException</code>，可以通过<code>@SuppressWarnings(&quot;unchecked&quot;)</code>消除警告，但不要直接忽略该警告</li>
<li>使用<code>@SuppressWarnings(&quot;unchecked&quot;)</code>时，应该在注视内证明确实不存在运行时的<code>ClassCastException</code>；同时应该尽量减小其作用的范围，通常是应该为一个赋值语句添加注解</li>
</ul>
</li>
<li><p>Item 25: Prefer lists to arrays</p>
<ul>
<li>arrays are covariant(协变): 如果<code>Sub</code>是<code>Super</code>的子类，那么<code>Sub[]</code>也是<code>Super[]</code>的子类</li>
<li>generics are invariant(不变): 任意两个不同的类<code>Type1</code>和<code>Type2</code>，<code>List&lt;Type1&gt;</code>和<code>List&lt;Type2&gt;</code>之间没有任何继承关系</li>
<li><p>考虑以下代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Fails at runtime!</span></div><div class="line">Object[] objectArray = <span class="keyword">new</span> Long[<span class="number">1</span>];</div><div class="line">objectArray[<span class="number">0</span>] = <span class="string">"I don't fit in"</span>; <span class="comment">// Throws ArrayStoreException</span></div><div class="line"></div><div class="line"><span class="comment">// Won't compile!</span></div><div class="line">List&lt;Object&gt; ol = <span class="keyword">new</span> ArrayList&lt;Long&gt;(); <span class="comment">// Incompatible types</span></div><div class="line">ol.add(<span class="string">"I don't fit in"</span>);</div></pre></td></tr></table></figure>
</li>
<li><p>arrays are reified(具体化): array在运行时能知道且强制要求元素的类型</p>
</li>
<li>generics are implemented by erasure(non-reifiable): 仅仅在编译时知道元素的类型</li>
<li>数组和泛型同时使用时会受到很大限制<ul>
<li>以下语句均不能通过编译：<code>new List&lt;E&gt;[], new List&lt;String&gt;[], new E[]</code>；但是声明是可以的，例如<code>List&lt;String&gt;[] stringLists</code></li>
</ul>
</li>
<li>non-reifiable type: 例如<code>E, List&lt;E&gt;, List&lt;String&gt;</code>，这些类型在运行时的信息比编译时的信息更少</li>
<li>只有unbounded wildcard type才是reifiable的，如：<code>List&lt;?&gt;, Map&lt;?, ?&gt;</code></li>
<li>常规来说，不能返回泛型元素的数组，因为会报编译错误：<code>generic array creation errors</code></li>
<li>当泛型和<code>varargs</code>一起使用时，也会导致编译警告</li>
<li>有时为了类型安全，不得不做些妥协，牺牲性能和简洁，使用List而不是数组</li>
<li>把数组强转为non-reifiable类型是非常危险的，仅应在非常确定类型安全的情况下使用</li>
</ul>
</li>
<li>Item 26: Favor generic types<ul>
<li>当需要一个类成员的数据类型具备一般性时，应该用泛型，这也正是泛型的设计场景之一，不应该用Object类</li>
<li>但使用泛型有时也不得不进行cast，例如当泛型遇上数组</li>
<li>总的来说把suppress数组类型强转的unchecked warning比suppress一个标量类型强转的unchecked warning风险更大，但有时出于代码简洁性考虑，也不得不做出妥协</li>
<li>有时看似与item 25矛盾，实属无奈，Java原生没有List，ArrayList不得不基于数组实现，HashMap也是基于数组实现的</li>
<li>泛型比使用者进行cast更加安全，而且由于Java泛型的擦除实现，也可以和未做泛型的老代码无缝兼容</li>
</ul>
</li>
<li><p>Item 27: Favor generic methods</p>
<ul>
<li><p>泛型方法的类型参数在函数修饰符（可见性/static/final等）和返回值之间，例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Generic method</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function">Set&lt;E&gt; <span class="title">union</span><span class="params">(Set&lt;E&gt; s1, Set&lt;E&gt; s2)</span> </span>&#123;</div><div class="line">    Set&lt;E&gt; result = <span class="keyword">new</span> HashSet&lt;&gt;(s1);</div><div class="line">    result.addAll(s2);</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>recursive type bound</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Using a recursive type bound to express mutual comparability</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&lt;T&gt;&gt; <span class="function">T <span class="title">max</span><span class="params">(List&lt;T&gt; list)</span> </span>&#123;...&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>泛型方法要比方法使用者进行cast更加安全</p>
</li>
</ul>
</li>
<li><p>Item 28: Use bounded wildcards to increase API flexibility</p>
<ul>
<li>考虑以下代码<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&lt;<span class="title">E</span>&gt; </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stack</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(E e)</span></span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">pop</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pushAll</span><span class="params">(Iterable&lt;E&gt; src)</span></span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">popAll</span><span class="params">(Collection&lt;E&gt; dst)</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Stack&lt;Number&gt; numberStack = <span class="keyword">new</span> Stack&lt;Number&gt;();</div><div class="line">Iterable&lt;Integer&gt; integers = ... ;</div><div class="line">numberStack.pushAll(integers);</div><div class="line"></div><div class="line">Stack&lt;Number&gt; numberStack = <span class="keyword">new</span> Stack&lt;Number&gt;();</div><div class="line">Collection&lt;Object&gt; objects = ... ;</div><div class="line">numberStack.popAll(objects);</div></pre></td></tr></table></figure>
</li>
</ul>
<p>pushAll和popAll的调用均无法通过编译，因为尽管<code>Integer</code>是<code>Number</code>的子类，但<code>Iterable&lt;Integer&gt;</code>不是<code>Iterable&lt;Number&gt;</code>的子类，这是由泛型的invariant特性导致的，所以<code>Iterable&lt;Integer&gt;</code>不能传入接受<code>Iterable&lt;Number&gt;</code>参数的函数，popAll的使用同理</p>
<ul>
<li>bounded wildcards: <code>&lt;? extends E&gt;</code>, <code>&lt;? super E&gt;</code>, PECS stands for producer-extends, consumer-super. 如果传入的参数是要输入给该类型数据的，则应该使用extends，如果是要容纳该类型数据的输出，则应该使用super</li>
<li>这很好理解，作为输入是要赋值给E类型的，当然应该是E的子类（这里的extends包括E类型本身）；而容纳输出是要把E赋值给传入参数的，当然应该是E的父类（同样包括E本身）</li>
<li>返回值类型不要使用bounded wildcards，否则使用者也需要使用，这将会给使用者造成麻烦</li>
<li>代码对于bounded wildcards的使用在使用者那边应该是透明的，即他们不会感知到bounded wildcards的存在，如果他们也需要考虑bounded wildcards的问题，则说明对bounded wildcards的使用有问题了</li>
<li><p>有时候编译器的类型推导在遇到bounded wildcards会无法完成，这时就需要显示指定类型信息，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function">Set&lt;E&gt; <span class="title">union</span><span class="params">(Set&lt;? extends E&gt; s1, Set&lt;? extends E&gt; s2)</span></span>;</div><div class="line"></div><div class="line">Set&lt;Integer&gt; integers = ... ;</div><div class="line">Set&lt;Double&gt; doubles = ... ;</div><div class="line"><span class="comment">//Set&lt;Number&gt; numbers = union(integers, doubles); //compile error</span></div><div class="line">Set&lt;Number&gt; numbers = Union.&lt;Number&gt;union(integers, doubles);  <span class="comment">//compile pass</span></div></pre></td></tr></table></figure>
</li>
<li><p>Comparables are always consumers, so you should always use <code>Comparable&lt;? super T&gt;</code> in preference to <code>Comparable&lt;T&gt;</code>. The same is true of comparators, so you should always use <code>Comparator&lt;? super T&gt;</code> in preference to <code>Comparator&lt;T&gt;</code>.</p>
</li>
<li>unbounded type parameter(<code>&lt;E&gt; ... List&lt;E&gt;</code>) v.s. unbounded wildcard(<code>List&lt;?&gt;</code>)：if a type parameter appears only once in a method declaration, replace it with a wildcard.</li>
</ul>
</li>
<li><p>Item 29: Consider typesafe heterogeneous containers</p>
<ul>
<li>使用泛型时，类型参数是有限个的，例如<code>List&lt;T&gt;</code>，<code>Map&lt;K, V&gt;</code>，但有时可能需要一个容器，能放入任意类型的对象，但需要具备类型安全性，例如数据库的一行，它的每一列都可能是任意类型的数据</li>
<li><p>由于<code>Class</code>类从1.5就被泛型化了，所以使得这种需求可以实现，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Typesafe heterogeneous container pattern - API</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Favorites</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">putFavorite</span><span class="params">(Class&lt;T&gt; type, T instance)</span></span>;</div><div class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getFavorite</span><span class="params">(Class&lt;T&gt; type)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>通常这样使用的<code>Class</code>对象被称为type token，它传入函数，用来表述编译时和运行时的类型信息</p>
</li>
<li><p><code>Favorites</code>的实现也是很简单的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Typesafe heterogeneous container pattern - implementation</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Favorites</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Map&lt;Class&lt;?&gt;, Object&gt; favorites = <span class="keyword">new</span> HashMap&lt;Class&lt;?&gt;, Object&gt;();</div><div class="line"></div><div class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">putFavorite</span><span class="params">(Class&lt;T&gt; type, T instance)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (type == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"Type is null"</span>);</div><div class="line">        favorites.put(type, instance);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getFavorite</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> type.cast(favorites.get(type));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>注意，这里的unbound wildcard并不是应用于Map的，而是应用于Class的类型参数，因此Map可以put key进去，而且key可以是任意类型参数的Class对象</p>
</li>
<li>另外，Map的value类型是Object，一旦put到Map中去，其编译期类型信息就丢失了，将通过get方法的动态类型转换（cast）来重新获得其类型信息</li>
<li>cast方法将检查类型信息，如果是该类型（或其子类），转换将成功，并返回引用，否则将抛出ClassCastException</li>
<li><p>这一heterogeneous container实现有两个不足</p>
<ul>
<li>通过为put方法传入Class的raw type，使用者可以很轻易地破坏类型安全性，解决方案也很简单，在put时也进行一下cast：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Achieving runtime type safety with a dynamic cast</span></div><div class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">putFavorite</span><span class="params">(Class&lt;T&gt; type, T instance)</span> </span>&#123;</div><div class="line">    favorites.put(type, type.cast(instance));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>这样做的效果是使得想要破坏类型安全性的put使用者产生异常，而使用get的使用者则不会因为恶意put使用者产生异常。这种做法也被<code>java.util.Collections</code>包中的一些方法使用，例如命名为checkedSet, checkedList, checkedMap的类。</p>
<ul>
<li>这个容器内不能放入non-reifiable的类型，例如<code>List&lt;String&gt;</code>，因为<code>List&lt;String&gt;.class</code>是有语法错误的，<code>List&lt;String&gt;</code>, <code>List&lt;Integer&gt;</code>都只有同一个class对象：<code>List.class</code>；另外<code>String[].class</code>是合法的。</li>
</ul>
</li>
<li><code>Favorites</code>使用的类型参数是unbounded的，可以put任意类型，也可以使用bounded type token，使用bounded时可能需要把<code>Class&lt;?&gt;</code>转换为<code>Class&lt;? extends Annotation&gt;</code>，直接用<code>class.cast</code>将会导致unchecked warning，可以通过<code>class.asSubclass</code>来进行转换，例子：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Use of asSubclass to safely cast to a bounded type token</span></div><div class="line"><span class="function"><span class="keyword">static</span> Annotation <span class="title">getAnnotation</span><span class="params">(AnnotatedElement element, String annotationTypeName)</span> </span>&#123;</div><div class="line">    Class&lt;?&gt; annotationType = <span class="keyword">null</span>; <span class="comment">// Unbounded type token</span></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        annotationType = Class.forName(annotationTypeName);</div><div class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(ex);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> element.getAnnotation(annotationType.asSubclass(Annotation.class));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="Enums-and-Annotations"><a href="#Enums-and-Annotations" class="headerlink" title="Enums and Annotations"></a>Enums and Annotations</h2><ul>
<li><p>Item 30: Use enums instead of int constants</p>
<ul>
<li>类型安全</li>
<li>可以为常量提供数据和方法的绑定</li>
<li>可以遍历</li>
<li><p>实现建议</p>
<ul>
<li>如果是通用的，应该定义为top level enum，否则应定义为内部类</li>
<li><p>constant-specific method implementations</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Enum type with constant-specific method implementations</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Operation &#123;</div><div class="line">    PLUS   &#123; <span class="function"><span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span>&#123;<span class="keyword">return</span> x + y;&#125; &#125;,</div><div class="line">    MINUS  &#123; <span class="function"><span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span>&#123;<span class="keyword">return</span> x - y;&#125; &#125;,</div><div class="line">    TIMES  &#123; <span class="function"><span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span>&#123;<span class="keyword">return</span> x * y;&#125; &#125;,</div><div class="line">    DIVIDE &#123; <span class="function"><span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span>&#123;<span class="keyword">return</span> x / y;&#125; &#125;;</div><div class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>结合constant-specific data</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Enum type with constant-specific class bodies and data</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Operation &#123;</div><div class="line">    PLUS(<span class="string">"+"</span>) &#123;</div><div class="line">        <span class="function"><span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123; <span class="keyword">return</span> x + y; &#125;</div><div class="line">    &#125;,</div><div class="line">    MINUS(<span class="string">"-"</span>) &#123;</div><div class="line">        <span class="function"><span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123; <span class="keyword">return</span> x - y; &#125;</div><div class="line">    &#125;,</div><div class="line">    TIMES(<span class="string">"*"</span>) &#123;</div><div class="line">        <span class="function"><span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123; <span class="keyword">return</span> x * y; &#125;</div><div class="line">    &#125;,</div><div class="line">    DIVIDE(<span class="string">"/"</span>) &#123;</div><div class="line">        <span class="function"><span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123; <span class="keyword">return</span> x / y; &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String symbol;</div><div class="line">    Operation(String symbol) &#123; <span class="keyword">this</span>.symbol = symbol; &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> symbol; &#125;</div><div class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>If switch statements on enums are not a good choice for implementing con- stant-specific behavior on enums, what are they good for? Switches on enums are good for augmenting external enum types with constant-specific behavior.</p>
</li>
</ul>
</li>
<li>A minor performance disadvantage of enums over int constants is that there is a space and time cost to load and initialize enum types.</li>
<li>所以，在安卓设备（手机、平板）上，应该避免使用enum，减小空间和时间的开销</li>
</ul>
</li>
<li>Item 31: Use instance fields instead of ordinals<ul>
<li>每个enum的常量都有一个<code>ordinal()</code>方法获取其在该enum类型中的位置，但该方法只应该在实现<code>EnumSet</code>, <code>EnumMap</code>等类型的时候被使用，其他情形都不应该被使用</li>
<li>如果需要为每一个常量绑定一个数据，可以使用instance field实现，如果需要绑定方法，则可以用constant-specific method implementations，参考上一个item</li>
</ul>
</li>
<li>Item 32: Use EnumSet instead of bit fields<ul>
<li>bit fields的方式不优雅、容易出错、没有类型安全性</li>
<li>EnumSet则没有这些缺点，而且对于大多数enum类型来说，其性能都和bit field相当</li>
<li>通用建议：声明变量时，不要用实现类型，应该用接口类型，例如，应该用<code>List&lt;Integer&gt;</code>而不是<code>ArrayList&lt;Integer&gt;</code></li>
<li>EnumSet并非immutable的，可以通过<code>Conllections.unmodifiableSet</code>来封装为immutable，但是代码简洁性与性能都将受到影响</li>
</ul>
</li>
<li><p>Item 33: Use EnumMap instead of ordinal indexing</p>
<ul>
<li>同前文所述，应该避免使用ordinal。当需要用enum作为下标从数组获取数据时，可以换个角度思考，以enum作为key从map里面获取数据。</li>
<li>数组和泛型不兼容，因此使用数组也会导致编译警告；而且ordinal的值本来就不是表达index含义的，极易导致隐蔽错误</li>
<li>EnumMap内部使用数组实现，因此性能和数组相当</li>
<li>使用数组也会导致程序可扩展性下降，考虑以下两种实现<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Using ordinal() to index array of arrays - DON'T DO THIS!</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Phase &#123;</div><div class="line">    SOLID, LIQUID, GAS;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> Transition &#123;</div><div class="line">      MELT, FREEZE, BOIL, CONDENSE, SUBLIME, DEPOSIT;</div><div class="line"></div><div class="line">      <span class="comment">// Rows indexed by src-ordinal, cols by dst-ordinal</span></div><div class="line">      <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Transition[][] TRANSITIONS = &#123;</div><div class="line">              &#123; <span class="keyword">null</span>,    MELT,     SUBLIME &#125;,</div><div class="line">              &#123; FREEZE,  <span class="keyword">null</span>,     BOIL    &#125;,</div><div class="line">              &#123; DEPOSIT, CONDENSE, <span class="keyword">null</span>    &#125;</div><div class="line">      &#125;;</div><div class="line"></div><div class="line">      <span class="comment">// Returns the phase transition from one phase to another</span></div><div class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Transition <span class="title">from</span><span class="params">(Phase src, Phase dst)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> TRANSITIONS[src.ordinal()][dst.ordinal()];</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Using a nested EnumMap to associate data with enum pairs</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Phase &#123;</div><div class="line">    SOLID, LIQUID, GAS;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> Transition &#123;</div><div class="line">        MELT(SOLID, LIQUID), FREEZE(LIQUID, SOLID),</div><div class="line">        BOIL(LIQUID, GAS),   CONDENSE(GAS, LIQUID),</div><div class="line">        SUBLIME(SOLID, GAS), DEPOSIT(GAS, SOLID);</div><div class="line"></div><div class="line">        <span class="keyword">final</span> Phase src;</div><div class="line">        <span class="keyword">final</span> Phase dst;</div><div class="line"></div><div class="line">        Transition(Phase src, Phase dst) &#123;</div><div class="line">            <span class="keyword">this</span>.src = src;</div><div class="line">            <span class="keyword">this</span>.dst = dst;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// Initialize the phase transition map</span></div><div class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Phase, Map&lt;Phase,Transition&gt;&gt; m =</div><div class="line">            <span class="keyword">new</span> EnumMap&lt;Phase, Map&lt;Phase,Transition&gt;&gt;(Phase.class);</div><div class="line">        <span class="keyword">static</span> &#123;</div><div class="line">            <span class="keyword">for</span> (Phase p : Phase.values())</div><div class="line">                m.put(p,<span class="keyword">new</span> EnumMap&lt;Phase,Transition&gt;(Phase.class));</div><div class="line">            <span class="keyword">for</span> (Transition trans : Transition.values())</div><div class="line">                m.get(trans.src).put(trans.dst, trans);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Transition <span class="title">from</span><span class="params">(Phase src, Phase dst)</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> m.get(src).get(dst);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>当需要增加<code>Phase</code>时，前者需要谨慎地修改<code>TRANSITIONS</code>数组的内容（这一步骤容易出错），而后者则只需要增加相应<code>Transition</code>即可，<code>from</code>函数的逻辑完全不受影响。</p>
</li>
<li>Item 34: Emulate extensible enums with interfaces<ul>
<li>当enum遇到可扩展性时，总是一个糟糕的问题；扩展类是基础类的实例，但反过来不是，这一点很让人困惑；想要枚举所有基础类和扩展类的enum对象时，并没有一个很好地办法；</li>
<li>而对于可扩展性的需求，是真实存在的，例如：operation codes (opcodes)</li>
<li>实现方式是通过定义一个接口，enum类型（基础与扩展）均实现该接口，而在使用enum的地方，接收这个接口作为参数</li>
<li>enum类型是不可扩展的，但是interface具备可扩展性，如果API使用接口而非实现去代表operation，API就有了可扩展性</li>
<li>泛型高级用法：<code>&lt;T extends Enum&lt;T&gt; &amp; Operation&gt; ... Class&lt;T&gt;</code>，T类型是enum类型，且是<code>Operation</code>子类</li>
<li>这一方式的不足：enum类型对接口的实现是不能继承的</li>
</ul>
</li>
<li>Item 35: Prefer annotations to naming patterns<ul>
<li>在1.5之前，naming patterns很常见，在JUnit中都是这样，例如要求测例方法一<code>test</code>开头</li>
<li>naming patterns有很多问题<ul>
<li>拼写错误不能及时发现</li>
<li>无法保证naming patterns只在正确的场景使用，例如可能有人以<code>test</code>开头命名测例类，方法却没有，JUnit则不会运行测例</li>
<li>没有值/类型信息，编译器无法提前发现问题</li>
</ul>
</li>
<li>使用annotations可以很好的解决这些问题，但是annotations的功能也是有限的<ul>
<li><code>@Retention(RetentionPolicy.RUNTIME)</code>能限定其保留时期</li>
<li><code>@Target(ElementType.METHOD)</code>能限定其应用的程序元素</li>
<li>还有其他meta-annotations，如<code>@IntDef</code></li>
</ul>
</li>
<li>annotations接收的参数如果是数组，为其赋值一个单独的元素也是合法的</li>
</ul>
</li>
<li>Item 36: Consistently use the Override annotation<ul>
<li><code>@Override</code>会使得重写的准确性得到检查</li>
<li>重载和重写的区别：一个只是函数名一样，通过参数列表决定执行哪个版本，是编译时多态；一个是通过虚函数机制实现，是运行时多态；</li>
</ul>
</li>
<li>Item 37: Use marker interfaces to define types<ul>
<li>定义一个空的接口，表明某个类型的属性，例如<code>Serializable</code></li>
<li>另一种方式是使用annotation，表明者其具有某种属性</li>
<li>marker interface的优点<ul>
<li>定义了一个类型，可以进行instanceof判断，可以声明参数类型</li>
<li>比annotation更简洁</li>
</ul>
</li>
<li>marker annotation的优点<ul>
<li>当一个类型（通过interface或者annotation）被声明后，如果想要加入更多的信息，annotation更方便，即annotation对修改是开放的，因为它的属性可以有默认值，而interface则不行，定义了方法就必须实现</li>
<li>annotation可以被应用到更多代码的元素中，不仅仅是类型</li>
</ul>
</li>
<li>实现建议<ul>
<li>如果仅仅只应用于类型，则应该优先考虑annotation</li>
<li>如果希望mark的对象被限定于某个接口的实例（即为一个接口增加另外一种语义，却不改变其API），可以考虑使用marker interface</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul>
<li>Item 38: Check parameters for validity<ul>
<li>一个函数（包括构造函数）首先要做的事情就是验证参数合法性，如果不合法则应该抛出相应异常，这是对“尽早发现错误尽早抛出”原则的遵循，否则等到错误发生时将可能难以判断错误的根源所在，甚至程序不会显式报错，而是执行了错误的行为，导致更严重的后果</li>
<li>不由被调用函数使用，而是存起来留作后用的参数，更加要检查其合法性</li>
<li>Javadoc里面应该注明<code>@throw</code>项，并说明原因</li>
<li>非公开的API（private或package private），则不应该通过抛异常来报错，应该采用<code>assert</code>，assert可以通过配置虚拟机参数开启或关闭，如果关闭则不会被执行</li>
<li>灵活运用，设计API时，就应该尽量设计得通用一些，即可以接受更大范围的参数，毕竟检查参数也是有开销的</li>
<li>另外可以考虑抛出<code>RuntimeException</code>的子类，因为这样的异常不用放到函数的异常表中，函数的使用者也不用必须<code>try-catch</code>或者<code>throw</code>，但doc一定要写明</li>
</ul>
</li>
<li>Item 39: Make defensive copies when needed<ul>
<li>编码一大原则：永远不要信任用户（调用方）输入的数据，也不要信任它们不会篡改返回的数据，因此defensive copy很有必要</li>
<li>编写一个类时，如果成员变量是mutable的，那么就需要在构造函数（或者setter）中进行深拷贝，并且，先拷贝，再验证已拷贝数据的合法性（既不是先验证，也不是验证传入的数据，避免TOCTOU attack）</li>
<li>另外深拷贝时，传入对象的类如果不是final的，就不能用clone方法进行拷贝，因为不能保证clone方法返回的就正好是这个类的实例（有可能会是恶意的子类）</li>
<li>为mutable成员提供getter方法时，返回前也要进行深拷贝，但此时可以用clone方法，因为我们确定成员就是我们想要的类的对象</li>
<li>java内建的Map, Set等容器，实现上是没有进行深拷贝的，因为是泛型，所以put进去或者get出来的时候，编译期都不知道具体是什么类型，是无法调用构造函数的，如果想要测试这一问题，需要确定key和value的类型都是mutable的，如果测<code>Map&lt;String, Integer&gt;</code>，那结果肯定是错误的，但如果测<code>Map&lt;StringBuilder, Date&gt;</code>，就可以知道确实如此；所以如果要把用户传入的数据放入Map，且key/value是mutable的，那么就需要在put之前进行深拷贝，否则可能会被用户attack</li>
<li>长度非零的数组都是mutable的</li>
<li>尽量使用immutable的成员就可以省去深拷贝带来的性能开销</li>
<li>如果确实信任用户，就可以把深拷贝省去，但一定要在文档内说明，例如：wrapper模式，如果用户恶意，那损害的也就仅仅是其自身；或者用户都是自己的代码，可以确信安全。</li>
</ul>
</li>
<li>Item 40: Design method signatures carefully<ul>
<li>命名要合理，可理解：清除表达函数的功能；符合常识；保持风格一致；</li>
<li>类/接口的成员方法数量不要太多，否则会令人难以理解，而且不利于测试、维护</li>
<li>不要随便提供helper方法，只有当很有必要时才提供</li>
<li>避免过长参数列表（不多于4个），尤其是参数类型相同，否则既难记（倒还好），又可能引起隐晦的bug（传入参数顺序错了，编译不报错，运行时行为确是错的）<ul>
<li>可以通过把参数列表过长的方法拆分为几个方法，但要避免导致方法过多</li>
<li>创建helper类，容纳作用相关联的的参数</li>
<li>类似于构造对象的Builder模式，为函数的调用创建一个builder</li>
</ul>
</li>
<li>参数类型，使用interface，而不是实现类</li>
<li>对于起控制作用的参数，使用二值enum，而不是boolean，便于扩展；对于安卓来说，可以通过<code>@IntDef</code>辅助定义int常量，模拟enum</li>
</ul>
</li>
<li>Item 41: Use overloading judiciously<ul>
<li>慎用重载，重载（overload）与重写（override）的区别可以见上文，简言之，前者编译时多态，后者运行时多态</li>
<li>重载是编译时多态，版本选择在编译期完成，根据编译期参数的类型信息来进行决策</li>
<li>建议不要用参数类型来设计不同的重载版本，应该通过参数列表长度，或者没有父子类关系的不同参数类型，例如接受int和float的类型，后者也还是可能会有问题</li>
</ul>
</li>
<li><p>Item 42: Use varargs judiciously</p>
<ul>
<li>varargs的原理是调用时首先创建一个数组，然后把传入的参数放入数组，数组长度为参数个数</li>
<li>一个方法需要0或多个同类型数据这个需求很常见，然而也有另一个很常见的需求：需要一个或多个同类型数据，此时单纯用varargs不太优雅，可以让方法先接受一个数据，在接受一个varargs</li>
<li>varargs最初是为了printf和反射设计的</li>
<li>可以通过把传入参数从一个数组改为varargs，来改良该方法（变得更灵活），而且对已有代码“无影响”，<code>Arrays.asList</code>便是一个例子，但接受varargs最初是为了打印数组内容设计的，而不是为了把多个数据变成一个List</li>
<li>Don’t retrofit every method that has a final array parameter; use varargs only when a call really operates on a variable-length sequence of values.</li>
<li><p>以下两种函数声明都可能会产生问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function">ReturnType1 <span class="title">suspect1</span><span class="params">(Object... args)</span> </span>&#123; &#125;</div><div class="line">&lt;T&gt; <span class="function">ReturnType2 <span class="title">suspect2</span><span class="params">(T... args)</span> </span>&#123; &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<pre><code>如果传入一个基本类型的数组进去（例如int[]），那么这两个方法接受的都是一个int[][]，即相当于接受了一个只有一个元素的数组，而这个数组的数据类型是int[]！而如果传入一个对象的数组，则相当于传入了数组长度个数的varargs。`Arrays.asList`方法就存在这个问题！
</code></pre><ul>
<li>varargs也存在性能影响，因为每次调用都会创建、初始化一个数组。如果为了不失API灵活性，同时大部分调用的参数个数都是有限个，例如0~3个，那么可以声明5个重载版本，分别接受0~3个参数，另外加一个3个参数+varargs的版本<ul>
<li>Item 43: Return empty arrays or collections, not nulls</li>
</ul>
</li>
<li>可能有人认为返回null能减小内存开销，然：<ul>
<li>永远不要过度考虑性能问题，只有当profiling显示瓶颈就是这里的时候，再考虑性能优化与代码优雅性的牺牲，当然，无副作用的优化肯定尽早采纳</li>
<li>可以每次需要返回空数组/集合时，返回同一个空数组/集合，这样就只需要一次内存分配</li>
</ul>
</li>
<li>Collection的<code>&lt;T&gt; T[] toArray(T[] a)</code>方法，可以每次调用时传入一个空数组，因为该方法保证如果集合元素可以被放入提供的参数数组中，将不会分配新内存，当放不下时才会分配</li>
<li><p>下面实现返回集合的值的方式也是值得借鉴的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// The right way to return a copy of a collection</span></div><div class="line"><span class="function"><span class="keyword">public</span> List&lt;Cheese&gt; <span class="title">getCheeseList</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (cheesesInStock.isEmpty())</div><div class="line">    <span class="keyword">return</span> Collections.emptyList(); <span class="comment">// Always returns same list</span></div><div class="line">  <span class="keyword">else</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;Cheese&gt;(cheesesInStock);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>Item 44: Write doc comments for all exposed API elements</p>
<ul>
<li>对于API暴露的部分（类、接口、方法、成员等），都应该先写好文档；为了提高代码的可维护性，未暴露的部分也应该写好文档；</li>
<li>每个方法的文档的内容，应该是描述该方法与调用者之间的约定，不必是实现细节，细节可以看代码，约定则是使用者关心的东西；设计为被继承的类，方法文档应该描述该方法做了什么，而不是怎么做的；</li>
<li>方法的文档中，应该描述约定的前提条件，执行后产生的影响，尤其是对于“系统”（或者说这个对象）状态的影响；不符合前提条件的情形将抛出异常；</li>
<li>更多细节<ul>
<li><code>@param</code>, <code>@return</code>, <code>@throws</code> 描述不要句号结尾</li>
<li><code>@throws</code> 的描述应该以if开头，其他都应该是名词描述</li>
<li><code>@{code}</code>与<code>@{literal}</code></li>
<li>有泛型时，需要说明每个类型参数</li>
<li>enum类型要为每个常量注释含义</li>
<li>annotation的定义，要为每个成员/参数注释含义</li>
<li>线程安全性说明，可见性说明，序列化说明</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="编程通用"><a href="#编程通用" class="headerlink" title="编程通用"></a>编程通用</h2><ul>
<li>Item 45: Minimize the scope of local variables<ul>
<li>在变量第一次使用的时候进行声明，声明时尽量就进行初始化</li>
<li>因此也更倾向于使用for-loop，而不是while-loop，因为后者需要使用while-loop外定义的控制变量</li>
<li>for-loop的终结条件变量n，也应该在循环变量i初始化时计算，避免重复计算</li>
<li>保持方法简短，一个方法只做一件事</li>
</ul>
</li>
<li>Item 46: Prefer for-each loops to traditional for loops<ul>
<li>优点之一：可以避免一些容易犯的bug<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Can you spot the bug?</span></div><div class="line"><span class="keyword">enum</span> Suit &#123; CLUB, DIAMOND, HEART, SPADE &#125;</div><div class="line"><span class="keyword">enum</span> Rank &#123; ACE, DEUCE, THREE, FOUR, FIVE, SIX, SEVEN, EIGHT,</div><div class="line">            NINE, TEN, JACK, QUEEN, KING &#125;</div><div class="line">...</div><div class="line">Collection&lt;Suit&gt; suits = Arrays.asList(Suit.values());</div><div class="line">Collection&lt;Rank&gt; ranks = Arrays.asList(Rank.values());</div><div class="line">List&lt;Card&gt; deck = <span class="keyword">new</span> ArrayList&lt;Card&gt;();</div><div class="line"><span class="keyword">for</span> (Iterator&lt;Suit&gt; i = suits.iterator(); i.hasNext(); )</div><div class="line">    <span class="keyword">for</span> (Iterator&lt;Rank&gt; j = ranks.iterator(); j.hasNext(); )</div><div class="line">        deck.add(<span class="keyword">new</span> Card(i.next(), j.next()));</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<pre><code>`i.next()`在内层循环被调用了多次。以下写法则直观且不易出错：

<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Preferred idiom for nested iteration on collections and arrays</span></div><div class="line"><span class="keyword">for</span> (Suit suit : suits)</div><div class="line">    <span class="keyword">for</span> (Rank rank : ranks)</div><div class="line">        deck.add(<span class="keyword">new</span> Card(suit, rank));</div></pre></td></tr></table></figure>
</code></pre><ul>
<li>此种写法不仅可用于集合和数组，任何实现<code>Iterable</code>接口的类都可以用于冒号后面的部分</li>
<li>缺点<ul>
<li>有性能代价！一定会创建Iterator，对于安卓开发，不建议如此。</li>
<li>不能在for-each语法中进行remove，用Iterator遍历时，能remove</li>
<li>遍历过程中替换原有元素</li>
<li>Parallel iteration</li>
<li>Item 47: Know and use the libraries</li>
</ul>
</li>
<li>don’t reinvent the wheel</li>
<li>视野！<ul>
<li>Item 48: Avoid float and double if exact answers are required</li>
</ul>
</li>
<li>float和double设计为用于科学计算，“精确近似”，需要确切结果的，不要使用，例如：货币相关！应该使用BigDecimal, int, 或者long。</li>
<li>BigDecimal使用有些不方便，性能也比primitive类型低<ul>
<li>Item 49: Prefer primitive types to boxed primitives</li>
</ul>
</li>
<li>两种类型的区别<ul>
<li>boxed类型，除了包含数值外，还有不同的唯一标示，即值一样，对象可以不一样，这一点很重要！</li>
<li>boxed类型，比primitive类型多一个值，null</li>
<li>boxed类型，时间、空间效率均低一些</li>
</ul>
</li>
<li>caveats<ul>
<li>有些操作会auto-unbox，例如：加减乘除，大小比较，但判等（<code>==</code>）不会！</li>
<li>Applying the <code>==</code> operator to boxed primitives is almost always wrong.</li>
<li>boxed类型，值为null时，会unbox为什么呢？会抛出<code>NullPointerException</code></li>
<li>当boxed和primitive出现在同一个运算中，boxed类型会auto-unbox（包括判等）</li>
<li>大量重复的box/unbox会导致性能大幅下降</li>
</ul>
</li>
<li>使用场景与注意事项<ul>
<li>放到标准集合里面，必须是boxed类型</li>
<li>作为类型参数（泛型），必须是boxed类型</li>
<li>auto-box是安全的，也能省去繁琐的代码，但是auto-unbox则可能引起隐蔽的错误</li>
<li>Item 50: Avoid strings where other types are more appropriate</li>
</ul>
</li>
<li>Strings are poor substitutes for other value types. 只有当数据确实就是文本时，才适合用String。</li>
<li>Strings are poor substitutes for enum types.</li>
<li>Strings are poor substitutes for aggregate types. 把一系列数据转化为一个String（序列化），然后再反序列化，也应该用Json，如果自定义分隔符，既不优雅，也不安全。</li>
<li>Strings are poor substitutes for capabilities. capability是一种称呼，通常就是说不同的对象，凭借一个key去同一个地方保存、获取数据；如果用String，那么如果内容相同，那key就会冲突，不安全；ThreadLocal的发展史*。<ul>
<li>Item 51: Beware the performance of string concatenation</li>
</ul>
</li>
<li>用<code>+</code>连接n个String，时间复杂度为<code>O(n^2)</code>，因为String是immutable的，所以每次拼接都会拷贝两者的内容</li>
<li>使用<code>StringBuilder</code>进行拼接操作；不过对于安卓开发来说，基本没什么影响，因为在打包的过程中，这一优化会自动完成；<ul>
<li>Item 52: Refer to objects by their interfaces</li>
</ul>
</li>
<li>如果有接口，那么函数参数、返回值、成员变量、局部变量，都应该使用接口来保持对象的引用，只有在通过构造函数创建对象时才应该引用具体的实现类型；面向接口编程更广义的实践；</li>
<li>面向接口编程使得程序更加灵活，切换实现类非常简单；但如果代码功能/正确性依赖于实现类特有的特性，那么切换时就需要仔细考虑一下；</li>
<li>当然，如果对应功能的接口不存在，那直接引用该类当然是可以的；value type; class-based framework; 或者实现类提供了接口不存在的功能<ul>
<li>Item 53: Prefer interfaces to reflection</li>
</ul>
</li>
<li>反射可以访问私有成员</li>
<li>反射可以调用编译时不存在的类的方法，当然需要运行时已经加载</li>
<li>但是反射也是有代价的<ul>
<li>编译期的类型检查完全失效，类型安全性丧失</li>
<li>反射代码繁琐且易出错，当然这一点有一些好的框架可以避免，例如<a href="https://github.com/jOOQ/jOOR" target="_blank" rel="external">JOOR</a></li>
<li>性能下降，反射调用性能会低很多</li>
</ul>
</li>
<li>反射常用的场景<ul>
<li>class browsers, object inspectors, code analysis tools, and interpretive embedded systems, remote procedure call (RPC) systems</li>
<li>反射功能强大，也有一些不足，如果合适利用，还是非常方便的</li>
<li>例如编译期有些类尚未获得，但是如果有其父类/接口，则可以声明为父类/接口，只通过反射创建实例，其余代码都无需反射</li>
<li>Item 54: Use native methods judiciously</li>
</ul>
</li>
<li>设计之初的三大用途<ul>
<li>访问平台相关的功能，例如registries and file locks</li>
<li>访问老的C/C++版本的库，访问老的数据</li>
<li>追求性能</li>
</ul>
</li>
<li>近年来JVM/Java的发展，性能已有很大改善，追求性能而使用JNI通常来说都已经没必要了</li>
<li>JNI的劣势<ul>
<li>不安全，内存管理不受JVM控制了，溢出等问题都有可能发生了</li>
<li>平台相关</li>
<li>难以调试</li>
<li>Java和native层的交互是有开销的</li>
<li>native代码比Java代码更难懂</li>
</ul>
</li>
<li>对于安卓应用开发来说，JNI还有一点就是隐藏实现，Java代码反编译非常容易，而native代码则难一些<ul>
<li>Item 55: Optimize judiciously</li>
</ul>
</li>
<li>只有当确实需要时，才考虑性能优化，当然一些常见的范式，初次编码时就应该遵循</li>
<li>Strive to write good programs rather than fast ones; speed will follow.</li>
<li>Strive to avoid design decisions that limit performance.</li>
<li>Consider the performance consequences of your API design decisions.</li>
<li>It is a very bad idea to warp an API to achieve good performance. </li>
<li>当确实需要优化性能时：measure performance before and after each attempted optimization.</li>
<li>找到原因后，首先考虑的是算法的优化，然后是上层的优化</li>
<li>在进行优化前，对程序进行profiling，确定瓶颈，否则可能浪费精力反而性能下降<ul>
<li>Item 56: Adhere to generally accepted naming conventions</li>
</ul>
</li>
<li>包名要体现出组件的层次结构，全小写</li>
<li>公布到外部的，包名以公司/组织的域名开头，例如：edu.cmu, com.sun</li>
<li>…</li>
</ul>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><ul>
<li>Item 57: Use exceptions only for exceptional conditions<ul>
<li>exceptions are, as their name implies, to be used only for exceptional conditions; they should never be used for ordinary control flow.</li>
<li>A well-designed API must not force its clients to use exceptions for ordinary control flow.<ul>
<li>如果一个类的某个方法，依赖于该类当前处于某个特定状态，则应该提供一个单独的状态检查方法，例如Iterator的next和hasNext方法</li>
<li>另外如果不提供状态检查方法，也可以让方法在异常状态下，返回一个特定的非法值</li>
<li>如果该类被并发访问，且访问时未进行互斥处理，则必须使用返回非法值的方式；另外考虑到性能因素，也更倾向于返回非法值；其他情况下，都应该使用状态检查方法，可读性更好，更容易检查错误；</li>
</ul>
</li>
</ul>
</li>
<li>Item 58: Use checked exceptions for recoverable conditions and runtime exceptions for programming errors<ul>
<li>use checked exceptions for conditions from which the caller can reasonably be expected to recover.</li>
<li>unchecked exception: <code>RuntimeException</code>, <code>Error</code>通常都不需要、也不应该catch</li>
<li>Use runtime exceptions to indicate programming errors. 通常用于表示程序运行的状态违背了前提条件，违背了API的约定</li>
<li>all of the unchecked throwables you implement should subclass RuntimeException</li>
</ul>
</li>
<li>Item 59: Avoid unnecessary use of checked exceptions<ul>
<li>如果即便合理的调用了API也会遇到异常情形，并且捕获异常之后能够进行一些有意义的操作，才应该使用checked exception，其他情况下都应该使用RuntimeException</li>
<li>通常，如果一个方法会抛出checked exception，都可以将其拆分为两个方法，一个用于判断是否会抛出异常，另一部分用于处理正常情况，如果不符合约定，就抛出RuntimeException，这样使得API更易用，也更灵活；但是要考虑状态检查和执行之间，是否可能从外部其他线程修改对象的状态；</li>
</ul>
</li>
<li>Item 60: Favor the use of standard exceptions<ul>
<li>IllegalArgumentException, IllegalStateException, NullPointerException, IndexOutOfBoundsException, ConcurrentModificationException, UnsupportedOperationException</li>
</ul>
</li>
<li><p>Item 61: Throw exceptions appropriate to the abstraction</p>
<ul>
<li><p>exception translation: higher layers should catch lower-level exceptions and, in their place, throw exceptions that can be explained in terms of the higher-level abstraction.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Exception Translation</span></div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    <span class="comment">// Use lower-level abstraction to do our bidding</span></div><div class="line">    ...</div><div class="line">&#125; <span class="keyword">catch</span>(LowerLevelException e) &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> HigherLevelException(...);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>While exception translation is superior to mindless propagation of excep- tions from lower layers, it should not be overused.</p>
</li>
</ul>
</li>
<li>Item 62: Document all exceptions thrown by each method<ul>
<li>Always declare checked exceptions individually, and document precisely the conditions under which each one is thrown using the Javadoc @throws tag. 不要通过声明抛出多个异常的父类来实现抛出多种异常的效果。</li>
<li>要为每个方法可能抛出的unchecked exception写文档，但是不要将这些异常放到方法声明的异常表中去。便于API使用者区分checked和unchecked exception。</li>
<li>如果一个类的很多方法都抛出同一个异常，那么可以将文档放到class doc中，而不是method doc中。</li>
</ul>
</li>
<li>Item 63: Include failure-capture information in detail messages<ul>
<li>To capture the failure, the detail message of an exception should contain the values of all parameters and fields that “contributed to the exception.”</li>
<li>良好设计的Exception类，应该把它需要的详细信息都作为构造函数的参数，而不是统一接收String参数；这样将把生成有意义的detail信息的任务集中在了Exception类本身，而不是其使用者。</li>
<li>checked exception可以为failure-capture information提供访问方法，以便于使用者在程序上进行恢复处理；虽然unchecked exception通常不会在程序中进行恢复，但是提供同样的方法也是建议的做法。</li>
</ul>
</li>
<li>Item 64: Strive for failure atomicity<ul>
<li>Generally speaking, a failed method invocation should leave the object in the state that it was in prior to the invocation. 满足此属性的方法称为 failure atomic。<ul>
<li>immutable对象是最简单的实现方法</li>
<li>mutable对象要达到此效果，就需要在进行操作前，对所有的参数、field进行检查</li>
<li>有可能无法在函数的第一部分进行检查，但是一定要在对对象进行修改之前进行检查</li>
<li>还有一种不太常见的方式：函数内部捕获异常，异常发生之后先回退对象的状态，再把异常抛出去</li>
<li>还可以先创建一个临时的对象，在临时对象上进行操作，成功后替换原对象的值</li>
</ul>
</li>
<li>有的情况下，failure atomic是不可能的，所以也就没必要为此做出努力了</li>
<li>有的情况下，为了failure atomic，会增加很多额外的开销、复杂度，也就不太必要了</li>
<li>当方法不满足failure atomic时，需要在文档中进行说明</li>
</ul>
</li>
<li>Item 65: Don’t ignore exceptions<ul>
<li>An empty catch block defeats the purpose of exceptions</li>
<li>At the very least, the catch block should contain a comment explaining why it is appropriate to ignore the exception.</li>
<li>忽略异常，可能导致程序在其他不相关的地方失败/崩溃，这时将很难找到/解决根本问题</li>
</ul>
</li>
</ul>
<h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><ul>
<li><p>Item 66: Synchronize access to shared mutable data</p>
<ul>
<li><code>synchronized</code>不仅是为了保证每个线程访问/执行时，看到的都是“正常状态”的对象（所谓正常就是没有发生多线程同时未加同步的写同一个对象，导致其状态不一致）；还能保证每个线程看到的都是最新的对象；</li>
<li>Java语言保证了基本类型中除了long和double的访问都是原子性的，并发写这些类型的数据而不进行同步控制，也不会有问题</li>
<li>有人建议访问具有原子性操作属性的对象无需进行同步控制，还能提升性能，纯属一派胡言</li>
<li>Java语言不会保证并发访问时，其他线程写的值能立即被读的线程感知，所以同步操作不仅仅是为了互斥访问，也是为了保证多线程之间看到的始终是最新的值</li>
<li>上述问题的根本原因就是<a href="Android-Java/JSR133.md">Java memory model</a></li>
<li><p>一个简单、常见、易错的例子</p>
<ul>
<li>如何停止后台线程？首先不能调用<code>Thread.stop</code>方法，这个方法会导致data corruption</li>
<li>常用的方法就是用一个<code>boolean</code>变量，后台线程根据其值决定是否停止，而主线程想要停止后台线程时，修改这个变量的值即可</li>
<li><code>boolean</code>的读写操作是原子性的，并发访问不加同步，不会导致data corruption，但是却无法保证主线程对变量的修改能及时被后台线程感知，甚至无法保证能被感知</li>
<li><p>指令重排，如果<code>done</code>就是个普通声明的<code>boolean</code>，以下变换在Java memory model下是允许的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span> (!done)</div><div class="line">  i++;</div><div class="line"></div><div class="line"><span class="comment">//==&gt;</span></div><div class="line"><span class="keyword">if</span> (!done)</div><div class="line">  <span class="keyword">while</span> (<span class="keyword">true</span>)</div><div class="line">    i++;</div></pre></td></tr></table></figure>
</li>
<li><p>可想而知，如果未进行同步操作，后台线程将永远不会停止</p>
</li>
<li>解决方法有两种</li>
<li>为<code>done</code>的读写访问都加上<code>synchronized</code>，注意，读写都需要，否则没有数据同步（communication）的效果；由于<code>boolean</code>的读写访问是原子性的，所以这里的<code>synchronized</code>仅仅起数据同步的作用；</li>
<li>声明<code>done</code>的时候加上<code>volatile</code>关键字，<code>volatile</code>没有互斥的作用，仅仅是起数据同步的作用，在这里正好满足需求；这种方式性能比上一种要好一些；</li>
</ul>
</li>
<li>使用<code>volatile</code>需要格外谨慎，因为它并没有互斥作用，如果声明一个<code>volatile int</code>，然后对其进行<code>++</code>操作，那将会导致data corruption，因为<code>++</code>不是原子性的</li>
<li>对于这种需求，可以声明为<code>synchronized int</code>；更好的方式是使用<code>java.util.concurrent.atomic</code>包下的类，安全，高效；</li>
<li>更根本的解决方式就是不要多线程共享mutable对象，而是共享immutable对象；甚至不要多线程共享数据；</li>
<li>引入框架/库时，需要考虑一下它们是否会引入多线程问题</li>
<li>effectively immutable：对象不是真的immutable，但是对象分享出去之后，就不会再改变了；当然这个还是很危险的，因为并没有强制的机制保证不会被修改；</li>
<li>小结：多线程访问共享变量时，读和写都需要进行同步操作</li>
</ul>
</li>
<li>Item 67: Avoid excessive synchronization<ul>
<li>在同步代码块中，不要调用可能被重写的方法，更不要调用使用者传入对象的方法，因为这些代码是不可控的，可能导致异常、死锁、data corruption</li>
<li>对于Observer模式中的observer list，Java 1.5之后有一个单独优化的高效并发容器：<code>CopyOnWriteArrayList</code>，每次写（添加、删除）操作都会从内部的数组创建一份新的拷贝，读（遍历）操作时完全不用加锁，对于读多写少的场景性能很好</li>
<li>一个总的原则是，在同步代码块中，执行尽可能少的操作；如果有耗时操作，应该在保证安全的前提下，尝试各种手段，将其移出同步块；</li>
<li>过度同步的性能影响<ul>
<li>丧失了多核CPU的并行性，获得锁的开销倒是其次</li>
<li>任何时刻都需要保证每个CPU核心之间的数据同步，这有不小的开销</li>
<li>限制了JVM的代码优化空间</li>
</ul>
</li>
<li>共享数据的并发访问，一定要保证线程安全；如果可以在类内部，通过少量/高效的同步块保证，就不要把整个类的任何操作都加锁；如果做不到，那就不要进行任何同步，把这个责任交给使用者，给他们优化的空间，但一定要在文档中说明；</li>
<li>如果<code>static</code>成员可以被某些方法修改，那一定要为它们加锁，因为这种情况下使用者无法保证线程安全性</li>
</ul>
</li>
<li><p>Item 68: Prefer executors and tasks to threads</p>
<ul>
<li>Executor Framework</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ExecutorService executor = Executors.newSingleThreadExecutor();</div><div class="line">executor.execute(runnable);</div><div class="line">executor.shutdown();</div></pre></td></tr></table></figure>
<ul>
<li><code>Executors</code>提供了多个工厂方法，创建<code>ExecutorService</code>，还可以直接使用<code>ThreadPoolExecutor</code>，对线程池做更精细的控制</li>
<li>如果程序负载轻，可以使用<code>Executors.newCachedThreadPool</code>，任务提交时如果没有空闲线程，将创建新的线程；如果负载重，用<code>Executors.newFixedThreadPool</code>更合适；</li>
<li>不仅不应该自己实现任务队列，甚至都应该避免直接使用线程，而是使用Executor Framework；</li>
<li>任务和机制被分别抽象了，前者为<code>Runnable</code>和<code>Callable</code>，后者则是executor service；</li>
<li><code>java.util.Timer</code>也尽量不要用了，可以使用<code>ScheduledThreadPoolExecutor</code>；</li>
</ul>
</li>
<li>Item 69: Prefer concurrency utilities to wait and notify<ul>
<li>正确使用<code>wait</code>和<code>notify</code>有难度，而Java又提供了更高层的抽象，何乐而不用呢？</li>
<li><code>java.util.concurrent</code>包主要包含三块：<ul>
<li>Executor Framework</li>
<li>concurrent collections</li>
<li>synchronizers</li>
</ul>
</li>
<li>concurrent collections提供了标准容器的多线程高性能版本，它们内部进行了同步互斥操作，保证正确性；外部使用的时候，无需加锁，否则只会导致性能下降；<ul>
<li>concurrent collections中的每一种实现，可能都有性能优化的侧重点，可能有的是多读少写高效，例如<code>CopyOnWriteArrayList</code>，所以使用时需要了解清楚其试用场景；</li>
<li>除非有明确的理由，否则，优先使用<code>ConcurrentHashMap</code>，而不是<code>Collections.synchronizedMap</code>或者<code>Hashtable</code>；也尽量避免在使用者那端进行同步操作；</li>
<li>有的concurrent collections提供了block操作接口，例如<code>BlockingQueue</code>，从中取数据的时候，如果队列为空，线程将等待，新的数据加入后，将自动唤醒等待的线程；大部分的<code>ExecutorService</code>都是采用这种方式实现的；</li>
</ul>
</li>
<li>Synchronizers: <code>CountDownLatch</code>, <code>Semaphore</code>, <code>CyclicBarrier</code>, <code>Exchanger</code><ul>
<li><code>CountDownLatch</code>: 多个线程等待另外一个或多个线程完成某种工作</li>
<li>注意thread starvation deadlock问题</li>
<li><code>Thread.currentThread().interrupt()</code> idiom：异常可能从其他线程抛出？用此方法回到原来的线程？</li>
<li>计时的话，用<code>System.nanoTime()</code>而不是<code>System.currentTimeMillis()</code>，前者更准确，更明确</li>
</ul>
</li>
<li>如果非要用<code>wait</code>和<code>notify</code>，注意以下几点：<ul>
<li>Always use the wait loop idiom to invoke the wait method; never invoke it outside of a loop.</li>
<li>wait前的条件检查可以保证不会死锁，wait后的检查可以保证安全</li>
<li>通常情况下都应该使用<code>notifyAll</code></li>
</ul>
</li>
</ul>
</li>
<li><p>Item 70: Document thread safety</p>
<ul>
<li>一个方法的声明中加了<code>synchronized</code>并不能保证它是线程安全的，并且Javadoc也不会把这个关键字输出到文档中</li>
<li>线程安全也分好几个层次，文档中应该说明类/方法做到了何种程度上的线程安全</li>
<li>线程安全的分类<ul>
<li>immutable，对象创建后不可修改，无需进行外部的同步操作（互斥访问控制或许更恰当）；例如：<code>String</code>, <code>Long</code>, <code>BigInteger</code>；</li>
<li>unconditionally thread-safe，对象可变，但是其内部进行了正确的同步操作，无需外部进行同步；例如：<code>ConcurrentHashMap</code>；</li>
<li>conditionally thread-safe，和绝对线程安全类似，但是有些方法需要进行外部的同步操作；例如：<code>Collections.synchronized</code>返回的容器，它们的iterator使用时需要进行同步；</li>
<li>not thread-safe，类自身没有任何同步操作，需要使用者自己保证线程安全；例如：<code>ArrayList</code>；</li>
<li>thread-hostile，由于类的实现原因，使用者无论如何也无法保证线程安全，例如未加同步的修改static成员；例如：<code>System.runFinalizersOnExit</code>；</li>
</ul>
</li>
<li>jsr-305引入了几个注解：<code>Immutable</code>, <code>ThreadSafe</code>, <code>NotThreadSafe</code>，对应上述前四种情形，绝对线程安全与条件线程安全都属<code>ThreadSafe</code>，对于条件线程安全还应在文档中说明何种情况下是需要外部进行同步的；</li>
<li><p>如果一个类，将它用于<code>synchronized</code>的对象暴露出去了，那是很危险的，通常的做法是，内部创建一个<code>Object</code>实例，将其用于<code>synchronized</code>，但这种方式通常只适用于unconditionally thread-safe的实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Private lock object idiom - thwarts denial-of-service attack</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">synchronized</span>(lock) &#123;</div><div class="line">    ...</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>Item 71: Use lazy initialization judiciously</p>
<ul>
<li>don’t do it unless you need to</li>
<li>如果使用lazy initialization，那这个成员的访问方法要用<code>synchronized</code>修饰</li>
<li><p>静态成员实现lazy initialization且希望高性能，使用lazy initialization holder class idiom，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Lazy initialization holder class idiom for static fields</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FieldHolder</span> </span>&#123;</div><div class="line">  <span class="keyword">static</span> <span class="keyword">final</span> FieldType field = computeFieldValue();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> FieldType <span class="title">getField</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> FieldHolder.field; &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>实例成员要实现lazy initialization且希望高性能，使用double-check idiom，但是注意，double-check并非严格意义的线程安全，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Double-check idiom for lazy initialization of instance fields </span></div><div class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> FieldType field;</div><div class="line"><span class="function">FieldType <span class="title">getField</span><span class="params">()</span> </span>&#123;</div><div class="line">  FieldType result = field;</div><div class="line">  <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;  <span class="comment">// First check (no locking)</span></div><div class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</div><div class="line">      result = field;</div><div class="line">      <span class="keyword">if</span> (result == <span class="keyword">null</span>)  <span class="comment">// Second check (with locking)</span></div><div class="line">        field = result = computeFieldValue();</div><div class="line">    &#125; </div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<pre><code>`result`这个局部变量的作用是，通常情况下，`field`已经初始化过了，这时将只会对其产生一次读操作，性能会有所提升
</code></pre><ul>
<li>double-check idiom还有两个变体，各有其使用场景：single-check idiom，racy single-check idiom；前者忍受多次赋值，后者忍受多次赋值且field的操作具有原子性（primitive类型且不是long和double）；<ul>
<li>Item 72: Don’t depend on the thread scheduler</li>
</ul>
</li>
<li>依赖线程调度器的正确性、性能的程序，很可能是无法移植的</li>
<li>好的多线程程序，同时运行的线程数不应该多于CPU内核数</li>
<li>线程无法进行有意义的工作时，就不应继续运行，忙等是不好的实现方式</li>
<li>另外一个线程（task）的工作也不能太少，否则线程切换的开销都会大于线程执行的时间，此时性能可想而知很低</li>
<li><code>Thread.yield</code> has no testable semantics. 所以不要用<code>Thread.yield</code>，当程序的有些线程因为线程过多而无法获得CPU时间时，应该减少线程数。</li>
<li>线程优先级是Java平台中移植性最差的部分，所以也不要用<ul>
<li>Item 73: Avoid thread groups</li>
</ul>
</li>
<li>如果设计的类需要处理一些逻辑上有关联的线程，应该考虑 thread pool executors </li>
</ul>
<h2 id="Serialization"><a href="#Serialization" class="headerlink" title="Serialization"></a>Serialization</h2><ul>
<li>Item 74: Implement Serializable judiciously<ul>
<li>实现<code>Serializable</code>接口之后，一旦类发布出去，就不能随意更改实现方式了，否则序列化-反序列化时可能失败，这降低了灵活性</li>
<li>序列化-反序列化的格式也是暴露的API之一，而默认的格式是和内部具体实现细节绑定的，所以默认格式把内部实现细节也暴露出去了</li>
<li>自定义序列化-反序列化格式（<code>ObjectOutputStream.putFields</code>, <code>ObjectInputStream.readFields</code>），可以缓解上述问题，但是这又带来了新的实现复杂度</li>
<li><code>serialVersionUID</code>问题</li>
<li>会增加bug、安全漏洞的可能性，因为反序列化得到的对象，其状态是无法保证的</li>
<li>会增加发布新版时的测试工作</li>
<li>被设计于用来被继承的类，谨慎实现<code>Serializable</code>接口，同样，设计的接口也谨慎继承<code>Serializable</code>接口</li>
<li>内部类不应该实现<code>Serializable</code>接口</li>
</ul>
</li>
<li>Item 75: Consider using a custom serialized form<ul>
<li>Do not accept the default serialized form without first considering whether it is appropriate.</li>
<li>The default serialized form is likely to be appropriate if an object’s physical representation is identical to its logical content.</li>
<li>Even if you decide that the default serialized form is appropriate, you often must provide a readObject method to ensure invariants and security.</li>
<li>Regardless of what serialized form you choose, declare an explicit serial version UID in every serializable class you write.</li>
</ul>
</li>
<li>Item 76: Write <code>readObject</code> methods defensively<ul>
<li><code>readObject</code>方法的功效和public的构造函数一样</li>
<li>反序列化的时候，<code>readObject</code>如果不进行深拷贝、以及数据合法性验证，就会导致生成的对象数据非法，同时，也有可能获得反序列化后对象内部成员的引用（rogue object reference attacks）</li>
<li>不要使用<code>writeUnshared</code>和<code>readUnshared</code>方法，它们并不安全</li>
<li>前文应该提到过，非final类，构造函数以及<code>readObject</code>方法中，不能调用可重载的方法</li>
</ul>
</li>
<li>Item 77: For instance control, prefer enum types to readResolve<ul>
<li>if you depend on readResolve for instance control, all instance fields with object reference types must be declared transient. 否则可能会无法达到实例控制的目的。</li>
<li>The accessibility of readResolve is significant.<ul>
<li>final类，应该置为private</li>
</ul>
</li>
</ul>
</li>
<li><p>Item 78: Consider serialization proxies instead of serialized instances</p>
<ul>
<li><p>为需要实现<code>Serializable</code>的类添加一个内部类，它的构造函数接收外部类的实例，并将其field拷贝到自身的field，并且实现<code>readResolve</code>方法，创建外部类实例，创建方法可以是构造函数、static factory函数，在其中就可以进行实例控制了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Serialization proxy for Period class</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializationProxy</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123; </div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Date start;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Date end;</div><div class="line">  </div><div class="line">  SerializationProxy(Period p) &#123;</div><div class="line">    <span class="keyword">this</span>.start = p.start;</div><div class="line">    <span class="keyword">this</span>.end = p.end;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="comment">// readResolve method for Period.SerializationProxy </span></div><div class="line">  <span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Period(start, end);  <span class="comment">// Uses public constructor</span></div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">234098243823485285L</span>; <span class="comment">// Any number will do (Item 75)</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>外部类实现一个<code>writeReplace</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// writeReplace method for the serialization proxy pattern</span></div><div class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">writeReplace</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> SerializationProxy(<span class="keyword">this</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>外部类实现<code>readObject</code>方法，并在其中抛出异常</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// readObject method for the serialization proxy pattern</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream stream)</span> <span class="keyword">throws</span> InvalidObjectException </span>&#123;</div><div class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> InvalidObjectException(<span class="string">"Proxy required"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>摘录来源：<a href="https://notes.piasy.com/Android-Java/EffectiveJava.html" target="_blank" rel="external">https://notes.piasy.com/Android-Java/EffectiveJava.html</a></p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://ocnyang.com/2016/10/24/day1024/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="OCN.Yang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/ocnyang.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="杨欧神/OCN.Yang">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/10/24/day1024/" itemprop="url">
                  你真的懂啥是1024吗？
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-10-24T09:03:15+08:00">
                2016-10-24
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2016/10/24/day1024/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/10/24/day1024/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2016/10/24/day1024/" class="leancloud_visitors" data-flag-title="你真的懂啥是1024吗？">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="你真的懂啥是1024吗？"><a href="#你真的懂啥是1024吗？" class="headerlink" title="你真的懂啥是1024吗？"></a>你真的懂啥是1024吗？</h1><p>今天就是一年一度的<a href="http://ocnyang.com/">1024节</a>了！</p>
<pre><code>package com.ocnyang.app;
/**
 * 程序员们，1024快乐。
 */
public class Hello1024 {
    public static final String PROGRAM_APES = &quot;程序猿&quot;;
    public static final String PROGRAM_GIRLS = &quot;程序媛&quot;; //这个真不知道怎么翻译了
    public static final String DATE_1024 = &quot;10月24日&quot;;

    public static void main(String args[]) {
        java.util.Calendar c = java.util.Calendar.getInstance();
        java.text.SimpleDateFormat f = new java.text.SimpleDateFormat(&quot;yyyy年MM月dd日hh时mm分ss秒&quot;);
        is1024(f.format(c.getTime()));
    }

    private static void is1024(String date) {
        if ((!android.text.TextUtils.isEmpty(date)) &amp;&amp; date.contains(DATE_1024))
            System.out.println(PROGRAM_APES + &quot;和&quot; + PROGRAM_GIRLS + &quot;,Happy 1024!&quot;);
    }
}
</code></pre><p>好吧并没有这个节，不过这个日子该庆祝啥，相信在座诸位很多人都懂的：</p>
<p>当然是庆祝二进制了！</p>
<p>1024是一个整数嘛。它等于 210，二进制表示为10000000000。</p>
<p>本来1024这种东西应该是数学家的玩具，但是不幸我们有了电脑，而电脑是基于二进制运行的，所以这个奇怪的数字就变得人尽皆知了……</p>
<h2 id="一个来自巧合的单位"><a href="#一个来自巧合的单位" class="headerlink" title="一个来自巧合的单位"></a>一个来自巧合的单位</h2><p>因为电脑的运行和存储都基于二进制，所以内存也好磁盘也好闪存也好，理论总容量应该是2的某次幂。老一些的内存都是64M、128M、256M、512M这样的数字，更老一些的电脑开机自检会在屏幕上读出内存容量，往往还要读3遍，经常能看到16384kB、65536kB这样的数字——这些也都是2的次幂。</p>
<p><img src="http://obbu6r1mi.bkt.clouddn.com/1024/1024.gif" alt="1024">  </p>
<p>可能今天多数人对2的次幂主要的熟悉来源，是2048这个游戏。虽然2048是明确复刻了1024，而1024则是抄袭了”Three!”的创意，但这种事情这里就不要提了吧。图片来源：imgur.com</p>
<p>但最常用的2次幂，当然还是1024——它是计算机领域的基本倍数：1M = 1024k，1G = 1024M，等等。</p>
<p>问题来了！<strong>1024和1000</strong>太接近了——一个有趣而有用的巧合，正因此它成了计算机的基本倍数；但另一些时候就烦人了。</p>
<p>210 ≈ 103，这个巧合在估算的时候很管用。比如想知道262是多少，就把它拆成260 × 22，前者约等于1018，后者等于4，因此就是4×1018。（实际上大约是4.61×1018，相差不大。）</p>
<p>但这只是数量级上相差不大，1024毕竟不等于1000。如果你买了一个4600T的硬盘，结果到手只有4000T，你可能就不开心了。</p>
<h2 id="到底是1000还是1024？"><a href="#到底是1000还是1024？" class="headerlink" title="到底是1000还是1024？"></a>到底是1000还是1024？</h2><p>其实现在硬盘几乎都在玩这个花招。计算机内部计算都是按照1024来算的，但是销售时却都会按照1000来宣称。比如我现在这个标称为500G的硬盘，实际上总可用空间是接近500000000000字节，对于计算机来说，只有465G。</p>
<p><img src="http://obbu6r1mi.bkt.clouddn.com/1024/10242.png" alt="1000or1024">  </p>
<p>然而你又不太好说他们错——k啊M啊这些前缀，都是从科学计数法的前缀里拿来的，人家本来就是指1000，只是在电脑里成了1024。这些前缀都来自希腊语：</p>
<ul>
<li><strong>kilo</strong>是1795年法国人设立公制的时候从希腊语改来的词，本来是1000，但计算机里1kB = 1024B；</li>
<li><strong>Mega</strong>来自希腊文“大”，1947年在科学计数法里确立为1000k，在计算机里就是1024k；</li>
<li><strong>Giga</strong>来自希腊文“非常大”，在科学计数法是1000M，计算机是1024M；</li>
<li><strong>Tera</strong>来自希腊文“怪物”，在科学计数法是1000G，计算机是1024G；</li>
<li><strong>Peta</strong>来自希腊文“五”，因为正常的大词用完了，于是改用“第五个1000”这种意思。在科学计数法是1000T，计算机是1024T。其实本来五应该写作penta，但是因为上一个词——Tera正好比“四”Tetra少一个字母，所以Peta也是故意去掉了中间的字母来保证不会和原词相混；</li>
<li><strong>Exa</strong>来自希腊文“六”，和hexa同根，但这次希腊文自己就没有保留那个“h”，所以沿用了；</li>
<li><strong>Zetta</strong>是本系列里唯一的异类。正常的希腊文“七”前缀应该是hepta，但没有使用，反而用了希腊数字体系里的Ζʹ（读作zeta）；</li>
<li><strong>Yotta</strong>则回归本源，来自希腊文“八”。</li>
</ul>
<p>一般用户几乎不会接触到P以上的级别。在T这一级上，二者的差距不到10%，大家通常也就忍了。</p>
<p>为了避免混淆，国际电工委员会（IEC）提出过一个标准：IEC 80000-13。在这个标准下，科学计数法（1000）按照正常标记，而计算机领域（1024）则全都加一个小写i。因此，1kB就是1000B，而1KiB才是1024B；1 MiB = 1024 KiB，1 GiB = 1024 MiB，等等。不幸的是，这个标准没有得到很广泛的使用，现在大家还是都是乱来的。</p>
<h2 id="最先用1024的可能是……埃及人？"><a href="#最先用1024的可能是……埃及人？" class="headerlink" title="最先用1024的可能是……埃及人？"></a>最先用1024的可能是……埃及人？</h2><p>大家平常喜欢说是中国人发明了二进制。这么说倒也不是不可以，二进制正式进入数学体系要归功于莱布尼兹，而莱布尼兹很喜欢中国，明确认为《易》所用的八卦和六十四卦就是一种二进制。但是古代中国人并没有使用这些二进制数进行计算。单纯说构想出二进制表达数字的办法，那很多文明都干过；然而古埃及人有一种乘法，真的是在用相当于二进制的方式来运算了。</p>
<p>比如，计算1262 × 13，他们会这样计算：</p>
<pre><code>1262 × 13 
= (1024 + 128 + 64 + 32 + 8 + 4 + 2) × 13
= 1024 ×  13 + 128 × 13 + 64 × 13 + 32 × 13 + 8 × 13 + 4 × 13 + 2 × 13
= 13312 + 1664 + 832 + 416 + 104 + 52 + 26
= 16406
</code></pre><p>等等，这是在干啥？</p>
<p>如果我们来做乘法的话，那么我们会：</p>
<pre><code>1262 × 13 
= 1000 × 13 + 200 × 13 + 60 × 13 + 2 × 13
</code></pre><p>……好像也差不多。</p>
<p>对，古埃及人也是把大数拆成小数来算乘法，但是我们拆成10、100、1000的倍数，而他们则拆成2、4、8、16、32、64……的倍数。这是二进制呀！</p>
<p>虽然不那么直观，但是二进制也有它的好处：便于不动脑查表格。按照我们十进制乘法，每一位都有10种可能：千位可能没有，也可能是1000、2000、3000、4000……9000。这样表格上就得留出9个位置。但是二进制乘法下，每一位要么有，要么没有。虽然要拆的次数变成了三倍（还记得为什么是三倍吗），但拆完之后就省事儿了。</p>
<p>这种计算方式并没有对后代产生很大影响，但每次我们敲出1024的时候，除了<a href="http://www.guokr.com/article/181723/" target="_blank" rel="external">达盖尔</a>的旗帜之外，似乎还是值得缅怀一下古埃及人？</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://ocnyang.com/2016/10/11/Gson_Guide4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="OCN.Yang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/ocnyang.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="杨欧神/OCN.Yang">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/10/11/Gson_Guide4/" itemprop="url">
                  Gson使用指南（四）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-10-11T12:03:15+08:00">
                2016-10-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/第三方框架/" itemprop="url" rel="index">
                    <span itemprop="name">第三方框架</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2016/10/11/Gson_Guide4/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/10/11/Gson_Guide4/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2016/10/11/Gson_Guide4/" class="leancloud_visitors" data-flag-title="Gson使用指南（四）">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Gson使用指南（四）"><a href="#Gson使用指南（四）" class="headerlink" title="Gson使用指南（四）"></a>Gson使用指南（四）</h1><blockquote>
<p>原文地址：<a href="http://www.jianshu.com/p/3108f1e44155" target="_blank" rel="external">http://www.jianshu.com/p/3108f1e44155</a>  </p>
</blockquote>
<p><strong>该系列其它文章</strong><br><a href="http://ocnyang.com/2016/10/11/Gson_Guide1/">Gson使用指南（一）</a><br><a href="http://ocnyang.com/2016/10/11/Gson_Guide2/">Gson使用指南（二）</a><br><a href="http://ocnyang.com/2016/10/11/Gson_Guide3/">Gson使用指南（三）</a><br><a href="http://ocnyang.com/2016/10/11/Gson_Guide4/">Gson使用指南（四）</a>  </p>
<blockquote>
<p>注：此系列基于Gson 2.4。</p>
</blockquote>
<p><strong>本次的主要内容：</strong></p>
<ul>
<li>TypeAdapter</li>
<li>JsonSerializer与JsonDeserializer</li>
<li>TypeAdapterFactory</li>
<li>@JsonAdapter注解</li>
<li>TypeAdapter与 JsonSerializer、JsonDeserializer对比</li>
<li>TypeAdapter实例</li>
<li>结语  </li>
</ul>
<h2 id="一、TypeAdapter"><a href="#一、TypeAdapter" class="headerlink" title="一、TypeAdapter"></a>一、TypeAdapter</h2><p><code>TypeAdapter</code> 是Gson自2.0（源码注释上说的是2.1）开始版本提供的一个抽象类，用于接管某种类型的序列化和反序列化过程，包含两个注要方法 <code>write(JsonWriter,T)</code> 和 <code>read(JsonReader)</code> 其它的方法都是final方法并最终调用这两个抽象方法。</p>
<pre><code>public abstract class TypeAdapter&lt;T&gt; {
    public abstract void write(JsonWriter out, T value) throws IOException;
    public abstract T read(JsonReader in) throws IOException;
    //其它final 方法就不贴出来了，包括`toJson`、`toJsonTree`、`toJson`和`nullSafe`方法。
}  
</code></pre><blockquote>
<p>注意：TypeAdapter 以及 JsonSerializer 和 JsonDeserializer 都需要与 GsonBuilder.registerTypeAdapter 示或GsonBuilder.registerTypeHierarchyAdapter配合使用，下面将不再重复说明。</p>
</blockquote>
<p>使用示例：</p>
<pre><code>User user = new User(&quot;怪盗kidou&quot;, 24);
user.emailAddress = &quot;ikidou@example.com&quot;;
Gson gson = new GsonBuilder()
        //为User注册TypeAdapter
        .registerTypeAdapter(User.class, new UserTypeAdapter())
        .create();
System.out.println(gson.toJson(user));  
</code></pre><p>UserTypeAdapter的定义：</p>
<pre><code>public class UserTypeAdapter extends TypeAdapter&lt;User&gt; {

    @Override
    public void write(JsonWriter out, User value) throws IOException {
        out.beginObject();
        out.name(&quot;name&quot;).value(value.name);
        out.name(&quot;age&quot;).value(value.age);
        out.name(&quot;email&quot;).value(value.email);
        out.endObject();
    }

    @Override
    public User read(JsonReader in) throws IOException {
        User user = new User();
        in.beginObject();
        while (in.hasNext()) {
            switch (in.nextName()) {
                case &quot;name&quot;:
                    user.name = in.nextString();
                    break;
                case &quot;age&quot;:
                    user.age = in.nextInt();
                    break;
                case &quot;email&quot;:
                case &quot;email_address&quot;:
                case &quot;emailAddress&quot;:
                    user.email = in.nextString();
                    break;
            }
        }
        in.endObject();
        return user;
    }
}  
</code></pre><p>当我们为User.class 注册了 TypeAdapter之后，只要是操作User.class 那些之前介绍的@SerializedName 、FieldNamingStrategy、Since、Until、Expos通通都黯然失色，失去了效果，只会调用我们实现的UserTypeAdapter.write(JsonWriter, User) 方法，我想怎么写就怎么写。</p>
<p>再说一个场景，在该系列的第一篇文章就说到了Gson有一定的容错机制，比如将字符串 “24” 转成int 的24,但如果有些情况下给你返了个空字符串怎么办（有人给我评论问到这个问题）?虽然这是服务器端的问题，但这里我们只是做一个示范。</p>
<p>int型会出错是吧，根据我们上面介绍的，我注册一个TypeAdapter 把 序列化和反序列化的过程接管不就行了?</p>
<pre><code>Gson gson = new GsonBuilder()
        .registerTypeAdapter(Integer.class, new TypeAdapter&lt;Integer&gt;() {
            @Override
            public void write(JsonWriter out, Integer value) throws IOException {
                out.value(String.valueOf(value)); 
            }
            @Override
            public Integer read(JsonReader in) throws IOException {
                try {
                    return Integer.parseInt(in.nextString());
                } catch (NumberFormatException e) {
                    return -1;
                }
            }
        })
        .create();
System.out.println(gson.toJson(100)); // 结果：&quot;100&quot;
System.out.println(gson.fromJson(&quot;\&quot;\&quot;&quot;,Integer.class)); // 结果：-1  
</code></pre><blockquote>
<p>注：测试空串的时候一定是”\”\””而不是””，””代表的是没有json串，”\”\””才代表json里的””。</p>
</blockquote>
<p>你说这一接管就要管两样好麻烦呀，我明明只想管序列化（或反列化）的过程的，另一个过程我并不关心，难道没有其它更简单的方法么? 当然有！就是接下来要介绍的 JsonSerializer与JsonDeserializer。</p>
<h2 id="二、JsonSerializer与JsonDeserializer"><a href="#二、JsonSerializer与JsonDeserializer" class="headerlink" title="二、JsonSerializer与JsonDeserializer"></a>二、JsonSerializer与JsonDeserializer</h2><p>JsonSerializer 和JsonDeserializer 不用像TypeAdapter一样，必须要实现序列化和反序列化的过程，你可以据需要选择，如只接管序列化的过程就用 JsonSerializer ，只接管反序列化的过程就用 JsonDeserializer ，如上面的需求可以用下面的代码。</p>
<pre><code>Gson gson = new GsonBuilder()
        .registerTypeAdapter(Integer.class, new JsonDeserializer&lt;Integer&gt;() {
            @Override
            public Integer deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException {
                try {
                    return json.getAsInt();
                } catch (NumberFormatException e) {
                    return -1;
                }
            }
        })
        .create();
System.out.println(gson.toJson(100)); //结果：100
System.out.println(gson.fromJson(&quot;\&quot;\&quot;&quot;, Integer.class)); //结果-1  
</code></pre><p>下面是所有数字都转成序列化为字符串的例子</p>
<pre><code>JsonSerializer&lt;Number&gt; numberJsonSerializer = new JsonSerializer&lt;Number&gt;() {
    @Override
    public JsonElement serialize(Number src, Type typeOfSrc, JsonSerializationContext context) {
        return new JsonPrimitive(String.valueOf(src));
    }
};
Gson gson = new GsonBuilder()
        .registerTypeAdapter(Integer.class, numberJsonSerializer)
        .registerTypeAdapter(Long.class, numberJsonSerializer)
        .registerTypeAdapter(Float.class, numberJsonSerializer)
        .registerTypeAdapter(Double.class, numberJsonSerializer)
        .create();
System.out.println(gson.toJson(100.0f));//结果：&quot;100.0&quot;  
</code></pre><blockquote>
<p>注：registerTypeAdapter必须使用包装类型，所以int.class,long.class,float.class和double.class是行不通的。同时不能使用父类来替上面的子类型，这也是为什么要分别注册而不直接使用Number.class的原因。</p>
</blockquote>
<p>上面特别说明了registerTypeAdapter不行，那就是有其它方法可行咯?当然！换成registerTypeHierarchyAdapter 就可以使用Number.class而不用一个一个的当独注册啦！</p>
<h3 id="registerTypeAdapter与registerTypeHierarchyAdapter的区别："><a href="#registerTypeAdapter与registerTypeHierarchyAdapter的区别：" class="headerlink" title="registerTypeAdapter与registerTypeHierarchyAdapter的区别："></a>registerTypeAdapter与registerTypeHierarchyAdapter的区别：</h3><p><img src="http://obbu6r1mi.bkt.clouddn.com/gson/gson_guide4_1.png" alt=""></p>
<p>注：如果一个被序列化的对象本身就带有泛型，且注册了相应的TypeAdapter，那么必须调用Gson.toJson(Object,Type)，明确告诉Gson对象的类型。</p>
<pre><code>Type type = new TypeToken&lt;List&lt;User&gt;&gt;() {}.getType();
TypeAdapter typeAdapter = new TypeAdapter&lt;List&lt;User&gt;&gt;() {
   //略
};
Gson gson = new GsonBuilder()
        .registerTypeAdapter(type, typeAdapter)
        .create();
List&lt;User&gt; list = new ArrayList&lt;&gt;();
list.add(new User(&quot;a&quot;,11));
list.add(new User(&quot;b&quot;,22));
//注意，多了个type参数
String result = gson.toJson(list, type);  
</code></pre><h2 id="三、TypeAdapterFactory"><a href="#三、TypeAdapterFactory" class="headerlink" title="三、TypeAdapterFactory"></a>三、TypeAdapterFactory</h2><p>TypeAdapterFactory,见名知意，用于创建TypeAdapter的工厂类，通过对比Type，确定有没有对应的TypeAdapter，没有就返回null，与GsonBuilder.registerTypeAdapterFactory配合使用。</p>
<pre><code>Gson gson = new GsonBuilder()
    .registerTypeAdapterFactory(new TypeAdapterFactory() {
        @Override
        public &lt;T&gt; TypeAdapter&lt;T&gt; create(Gson gson, TypeToken&lt;T&gt; type) {
            return null;
        }
    })
    .create();  
</code></pre><h2 id="四、-JsonAdapter注解"><a href="#四、-JsonAdapter注解" class="headerlink" title="四、@JsonAdapter注解"></a>四、@JsonAdapter注解</h2><p>JsonAdapter相较之前介绍的SerializedName 、FieldNamingStrategy、Since、Until、Expos这几个注解都是比较特殊的，其它的几个都是用在POJO的字段上，而这一个是用在POJO类上的，接收一个参数，且必须是TypeAdpater，JsonSerializer或JsonDeserializer这三个其中之一。</p>
<p>上面说JsonSerializer和JsonDeserializer都要配合GsonBuilder.registerTypeAdapter使用，但每次使用都要注册也太麻烦了，JsonAdapter就是为了解决这个痛点的。</p>
<p>使用方法（以User为例）：</p>
<pre><code>@JsonAdapter(UserTypeAdapter.class) //加在类上
public class User {
    public User() {
    }
    public User(String name, int age) {
        this.name = name;
        this.age = age;
    }
    public User(String name, int age, String email) {
        this.name = name;
        this.age = age;
        this.email = email;
    }
    public String name;
    public int age;
    @SerializedName(value = &quot;emailAddress&quot;)
    public String email;
}  
</code></pre><p>使用时不用再使用 GsonBuilder去注册UserTypeAdapter了。<br>注：@JsonAdapter 仅支持 TypeAdapter或TypeAdapterFactory</p>
<pre><code>Gson gson = new Gson();
User user = new User(&quot;怪盗kidou&quot;, 24, &quot;ikidou@example.com&quot;);
System.out.println(gson.toJson(user));
//结果：{&quot;name&quot;:&quot;怪盗kidou&quot;,&quot;age&quot;:24,&quot;email&quot;:&quot;ikidou@example.com&quot;}
//为区别结果，特意把email字段与@SerializedName注解中设置的不一样  
</code></pre><p>注意：JsonAdapter的优先级比GsonBuilder.registerTypeAdapter的优先级更高。</p>
<h2 id="五、TypeAdapter与-JsonSerializer、JsonDeserializer对比"><a href="#五、TypeAdapter与-JsonSerializer、JsonDeserializer对比" class="headerlink" title="五、TypeAdapter与 JsonSerializer、JsonDeserializer对比"></a>五、TypeAdapter与 JsonSerializer、JsonDeserializer对比</h2><p><img src="http://obbu6r1mi.bkt.clouddn.com/gson/gson_guide4_2.png" alt=""></p>
<h2 id="六、TypeAdapter实例"><a href="#六、TypeAdapter实例" class="headerlink" title="六、TypeAdapter实例"></a>六、TypeAdapter实例</h2><p>注：这里的TypeAdapter泛指TypeAdapter、JsonSerializer和JsonDeserializer。<br>这里的TypeAdapter 上面讲了一个自动将 字符串形式的数值转换成int型时可能出现 空字符串的问题，下面介绍一个其它读者的需求：</p>
<blockquote>
<p>服务器返回的数据中data字段类型不固定，比如请求成功data是一个List,不成功的时候是String类型，这样前端在使用泛型解析的时候，怎么去处理呢？  </p>
</blockquote>
<p>其实这个问题的原因主要由服务器端造成的，接口设计时没有没有保证数据的一致性，正确的数据返回姿势：<strong>同一个接口任何情况下不得改变返回类型，要么就不要返，要么就返空值，如<code>null、[],{}。</code></strong></p>
<p>但这里还是给出解决方案：<br><strong>方案一：</strong> </p>
<pre><code>Gson gson = new GsonBuilder().registerTypeHierarchyAdapter(List.class, new JsonDeserializer&lt;List&lt;?&gt;&gt;() {
    @Override
    public List&lt;?&gt; deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException {
        if (json.isJsonArray()){
            //这里要自己负责解析了
            Gson newGson = new Gson();
            return newGson.fromJson(json,typeOfT);
        }else {
            //和接口类型不符，返回空List
            return Collections.EMPTY_LIST;
        }
    }
}).create();  
</code></pre><p><strong>方案二：</strong></p>
<pre><code> Gson gson = new GsonBuilder().registerTypeHierarchyAdapter(List.class, new JsonDeserializer&lt;List&lt;?&gt;&gt;() {
    @Override
    public List&lt;?&gt; deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context) throws JsonParseException {
        if (json.isJsonArray()) {
            JsonArray array = json.getAsJsonArray();
            Type itemType = ((ParameterizedType) typeOfT).getActualTypeArguments()[0];
            List list = new ArrayList&lt;&gt;();
            for (int i = 0; i &lt; array.size(); i++) {
                JsonElement element = array.get(i);
                Object item = context.deserialize(element, itemType);
                list.add(item);
            }
            return list;
        } else {
            //和接口类型不符，返回空List
            return Collections.EMPTY_LIST;
        }
    }
}).create();  
</code></pre><p>要注意的点：</p>
<ul>
<li>必须使用registerTypeHierarchyAdapter方法，不然对List的子类无效，但如果POJO中都是使用List，那么可以使用registerTypeAdapter。</li>
<li>对于是数组的情况，需要创建一个新的Gson，不可以直接使用context,不然gson又会调我们自定义的JsonDeserializer造成递归调用，方案二没有重新创建Gson，那么就需要提取出List<e>中E的类型，然后分别反序列化适合为E手动注册了TypeAdaper的情况。</e></li>
<li>从效率上推荐方案二，免去重新实例化Gson和注册其它TypeAdapter的过程。  </li>
</ul>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>Gson系列总算是完成了，感觉写得越来越差了，我怕我写得太啰嗦，也不能总是大片大片的贴代码，所以可能有的地方写得并不详细，排版也不美观，但都些都不重点，重点是Gson里我们能用上的都一一介绍一遍，只要你确确实实把我这几篇文章上的内容都学会的话，以后Gson上的任何问题都不再是问题，当然可能很多内容对于实际的开发中用的并不多，但下次有什么疑难杂症就难不倒你了。</p>
<p>本系列不提供Demo源码，最重要的是自己实验。</p>
<p>写一篇文章还是要花不少时间和精力，要写示例、调式、组织语言、码字等等，加上关注的人在慢慢的增加的同时既给了我动力也给我不少压力，如有纰漏或者更好的例子都可以和我交流。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://ocnyang.com/2016/10/11/Gson_Guide3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="OCN.Yang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/ocnyang.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="杨欧神/OCN.Yang">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/10/11/Gson_Guide3/" itemprop="url">
                  Gson使用指南（三）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-10-11T11:03:15+08:00">
                2016-10-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/第三方框架/" itemprop="url" rel="index">
                    <span itemprop="name">第三方框架</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2016/10/11/Gson_Guide3/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/10/11/Gson_Guide3/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2016/10/11/Gson_Guide3/" class="leancloud_visitors" data-flag-title="Gson使用指南（三）">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Gson使用指南（三）"><a href="#Gson使用指南（三）" class="headerlink" title="Gson使用指南（三）"></a>Gson使用指南（三）</h1><blockquote>
<p>原文地址：<a href="http://www.jianshu.com/p/0e40a52c0063" target="_blank" rel="external">http://www.jianshu.com/p/0e40a52c0063</a>  </p>
</blockquote>
<p><strong>该系列其它文章</strong><br><a href="http://ocnyang.com/2016/10/11/Gson_Guide1/">Gson使用指南（一）</a><br><a href="http://ocnyang.com/2016/10/11/Gson_Guide2/">Gson使用指南（二）</a><br><a href="http://ocnyang.com/2016/10/11/Gson_Guide3/">Gson使用指南（三）</a><br><a href="http://ocnyang.com/2016/10/11/Gson_Guide4/">Gson使用指南（四）</a>  </p>
<blockquote>
<p>注：此系列基于Gson 2.4。</p>
</blockquote>
<p><strong>本次的主要内容：</strong></p>
<ul>
<li>字段过滤的几种方法<ul>
<li>基于@Expose注解</li>
<li>基于版本</li>
<li>基于访问修饰符</li>
<li>基于策略（作者最常用）</li>
</ul>
</li>
<li>POJO与JSON的字段映射规则  </li>
</ul>
<h2 id="一、字段过滤的几种方法"><a href="#一、字段过滤的几种方法" class="headerlink" title="一、字段过滤的几种方法"></a>一、字段过滤的几种方法</h2><p>字段过滤Gson中比较常用的技巧，特别是在Android中，在处理业务逻辑时可能需要在设置的POJO中加入一些字段，但显然在序列化的过程中是不需要的，并且如果序列化还可能带来一个问题就是 <strong>循环引用</strong> ，那么在用Gson序列化之前为不防止这样的事件情发生，你不得不作另外的处理。</p>
<p>以一个商品分类Category 为例。</p>
<pre><code>{
  &quot;id&quot;: 1,
  &quot;name&quot;: &quot;电脑&quot;,
  &quot;children&quot;: [
    {
      &quot;id&quot;: 100,
      &quot;name&quot;: &quot;笔记本&quot;
    },
    {
      &quot;id&quot;: 101,
      &quot;name&quot;: &quot;台式机&quot;
    }
  ]
}  
</code></pre><p>一个大分类，可以有很多小分类，那么显然我们在设计Category类时Category本身既可以是大分类，也可以是小分类。</p>
<pre><code>public class Category {
    public int id;
    public String name;
    public List&lt;Category&gt; children;
}  
</code></pre><p>但是为了处理业务，我们还需要在子分类中保存父分类，最终会变成下面的情况</p>
<pre><code>public class Category {
    public int id;
    public String name;
    public List&lt;Category&gt; children;
    //因业务需要增加，但并不需要序列化
    public Category parent; 
}  
</code></pre><p>但是上面的parent字段是因业务需要增加的，那么在序列化是并不需要，所以在序列化时就必须将其排除，那么在Gson中如何排除符合条件的字段呢?下面提供4种方法，大家可根据需要自行选择合适的方式。</p>
<h3 id="基于-Expose注解"><a href="#基于-Expose注解" class="headerlink" title="基于@Expose注解"></a>基于@Expose注解</h3><p>@Expose提供了两个属性，且都有默认值，开发者可以根据需要设置不同的值。</p>
<p><img src="http://obbu6r1mi.bkt.clouddn.com/gson/gson_guide3_1.png" alt="@Expose">  </p>
<p>@Expose 注解从名字上就可以看出是暴露的意思，所以该注解是用于对处暴露字段的。可是我们以前用Gson的时候也没有@Expose 注解还是不正确的序列化为JSON了么?是的，所以该注解在使用new Gson() 时是不会发生作用。毕竟最常用的API要最简单，所以该注解必须和GsonBuilder配合使用。</p>
<p>使用方法： 简单说来就是需要导出的字段上加上@Expose 注解，不导出的字段不加。注意是不导出的不加。</p>
<pre><code>@Expose //
@Expose(deserialize = true,serialize = true) //序列化和反序列化都都生效
@Expose(deserialize = true,serialize = false) //反序列化时生效
@Expose(deserialize = false,serialize = true) //序列化时生效
@Expose(deserialize = false,serialize = false) // 和不写一样  
</code></pre><blockquote>
<p>注：根据上面的图片可以得出，所有值为true的属性都是可以不写的。</p>
</blockquote>
<p>拿上面的例子来说就是</p>
<pre><code>public class Category {
    @Expose public int id;
    @Expose public String name;
    @Expose public List&lt;Category&gt; children;
    //不需要序列化,所以不加 @Expose 注解，
    //等价于 @Expose(deserialize = false,serialize = false)
    public Category parent; 
}  
</code></pre><p>在使用Gson时也不能只是简单的new Gson()了。</p>
<pre><code>Gson gson = new GsonBuilder()
        .excludeFieldsWithoutExposeAnnotation()
        .create();
gson.toJson(category);  
</code></pre><h3 id="基于版本"><a href="#基于版本" class="headerlink" title="基于版本"></a>基于版本</h3><p>Gson在对基于版本的字段导出提供了两个注解 @Since 和 @Until,和GsonBuilder.setVersion(Double)配合使用。@Since 和 @Until都接收一个Double值。</p>
<p><img src="http://obbu6r1mi.bkt.clouddn.com/gson/gson_guide3_2.png" alt="Since和Until注解">   </p>
<p>使用方法：当前版本(GsonBuilder中设置的版本) 大于等于Since的值时该字段导出，小于Until的值时该该字段导出。</p>
<pre><code>class SinceUntilSample {
    @Since(4)
    public String since;
    @Until(5)
    public String until;
}

public void sineUtilTest(double version){
        SinceUntilSample sinceUntilSample = new SinceUntilSample();
        sinceUntilSample.since = &quot;since&quot;;
        sinceUntilSample.until = &quot;until&quot;;
        Gson gson = new GsonBuilder().setVersion(version).create();
        System.out.println(gson.toJson(sinceUntilSample));
}
//当version &lt;4时，结果：{&quot;until&quot;:&quot;until&quot;}
//当version &gt;=4 &amp;&amp; version &lt;5时，结果：{&quot;since&quot;:&quot;since&quot;,&quot;until&quot;:&quot;until&quot;}
//当version &gt;=5时，结果：{&quot;since&quot;:&quot;since&quot;}  
</code></pre><blockquote>
<p>注：当一个字段被同时注解时，需两者同时满足条件。</p>
</blockquote>
<h3 id="基于访问修饰符"><a href="#基于访问修饰符" class="headerlink" title="基于访问修饰符"></a>基于访问修饰符</h3><p>什么是修饰符? public、static 、final、private、protected 这些就是，所以这种方式也是比较特殊的。<br>使用方式：</p>
<pre><code>class ModifierSample {
    final String finalField = &quot;final&quot;;
    static String staticField = &quot;static&quot;;
    public String publicField = &quot;public&quot;;
    protected String protectedField = &quot;protected&quot;;
    String defaultField = &quot;default&quot;;
    private String privateField = &quot;private&quot;;
}  
</code></pre><p>使用GsonBuilder.excludeFieldsWithModifiers构建gson,支持int形的可变参数，值由java.lang.reflect.Modifier提供，下面的程序排除了privateField 、 finalField 和staticField 三个字段。</p>
<pre><code>ModifierSample modifierSample = new ModifierSample();
Gson gson = new GsonBuilder()
        .excludeFieldsWithModifiers(Modifier.FINAL, Modifier.STATIC, Modifier.PRIVATE)
        .create();
System.out.println(gson.toJson(modifierSample));
// 结果：{&quot;publicField&quot;:&quot;public&quot;,&quot;protectedField&quot;:&quot;protected&quot;,&quot;defaultField&quot;:&quot;default&quot;}  
</code></pre><p>到此为止，Gson提供的所有注解就还有一个@JsonAdapter没有介绍了，而@JsonAdapter将和TypeAdapter将作为该系列第4篇也是最后一篇文章的主要内容。</p>
<h3 id="基于策略（自定义规则）"><a href="#基于策略（自定义规则）" class="headerlink" title="基于策略（自定义规则）"></a>基于策略（自定义规则）</h3><p>上面介绍的了3种排除字段的方法，说实话我除了@Expose以外，其它的都是只在Demo用上过，用得最多的就是马上要介绍的自定义规则，好处是功能强大、灵活，缺点是相比其它3种方法稍麻烦一点，但也仅仅只是想对其它3种稍麻烦一点而已。</p>
<p>基于策略是利用Gson提供的ExclusionStrategy接口，同样需要使用GsonBuilder,相关API 2个，分别是addSerializationExclusionStrategy 和addDeserializationExclusionStrategy 分别针对序列化和反序化时。这里以序列化为例。</p>
<p>例如：</p>
<pre><code>Gson gson = new GsonBuilder()
        .addSerializationExclusionStrategy(new ExclusionStrategy() {
            @Override
            public boolean shouldSkipField(FieldAttributes f) {
                // 这里作判断，决定要不要排除该字段,return true为排除
                if (&quot;finalField&quot;.equals(f.getName())) return true; //按字段名排除
                Expose expose = f.getAnnotation(Expose.class); 
                if (expose != null &amp;&amp; expose.deserialize() == false) return true; //按注解排除
                return false;
            }
            @Override
            public boolean shouldSkipClass(Class&lt;?&gt; clazz) {
                // 直接排除某个类 ，return true为排除
                return (clazz == int.class || clazz == Integer.class);
            }
        })
        .create();  
</code></pre><p>有没有很强大?</p>
<h2 id="二、-POJO与JSON的字段映射规则"><a href="#二、-POJO与JSON的字段映射规则" class="headerlink" title="二、 POJO与JSON的字段映射规则"></a>二、 POJO与JSON的字段映射规则</h2><p>之前在<strong>Gson使用指南（二）</strong> 属性重命名时 介绍了@SerializedName这个注解的使用，本节的内容与上一次差不多的，但既然叫 <strong>映射规则</strong> 那么说的自然是有规律的情况。<br>还是之前User的例子，已经去除所有注解：</p>
<pre><code>User user = new User(&quot;怪盗kidou&quot;, 24);
user.emailAddress = &quot;ikidou@example.com&quot;;  
</code></pre><p>GsonBuilder提供了FieldNamingStrategy接口和setFieldNamingPolicy和setFieldNamingStrategy 两个方法。</p>
<h3 id="默认实现"><a href="#默认实现" class="headerlink" title="默认实现"></a>默认实现</h3><p>GsonBuilder.setFieldNamingPolicy 方法与Gson提供的另一个枚举类FieldNamingPolicy配合使用，该枚举类提供了5种实现方式分别为：</p>
<p><img src="http://obbu6r1mi.bkt.clouddn.com/gson/gson_guide3_3.png" alt="">  </p>
<h3 id="自定义实现"><a href="#自定义实现" class="headerlink" title="自定义实现"></a>自定义实现</h3><p>GsonBuilder.setFieldNamingStrategy 方法需要与Gson提供的FieldNamingStrategy接口配合使用，用于实现将POJO的字段与JSON的字段相对应。上面的FieldNamingPolicy实际上也实现了FieldNamingStrategy接口，也就是说FieldNamingPolicy也可以使用setFieldNamingStrategy方法。</p>
<p>用法：</p>
<pre><code>Gson gson = new GsonBuilder()
        .setFieldNamingStrategy(new FieldNamingStrategy() {
            @Override
            public String translateName(Field f) {
                //实现自己的规则
                return null;
            }
        })
        .create();  
</code></pre><p>注意： @SerializedName注解拥有最高优先级，在加有@SerializedName注解的字段上FieldNamingStrategy不生效！</p>
<p>本文完</p>
<h2 id="下期预告（本系列最终篇）："><a href="#下期预告（本系列最终篇）：" class="headerlink" title="下期预告（本系列最终篇）："></a>下期预告（本系列最终篇）：</h2><ul>
<li>无所不能的TypeAdapter</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://ocnyang.com/2016/10/11/Gson_Guide2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="OCN.Yang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/ocnyang.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="杨欧神/OCN.Yang">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/10/11/Gson_Guide2/" itemprop="url">
                  Gson使用指南（二）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-10-11T10:03:15+08:00">
                2016-10-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/第三方框架/" itemprop="url" rel="index">
                    <span itemprop="name">第三方框架</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2016/10/11/Gson_Guide2/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/10/11/Gson_Guide2/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2016/10/11/Gson_Guide2/" class="leancloud_visitors" data-flag-title="Gson使用指南（二）">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Gson使用指南（二）"><a href="#Gson使用指南（二）" class="headerlink" title="Gson使用指南（二）"></a>Gson使用指南（二）</h1><blockquote>
<p>原文地址：<a href="http://www.jianshu.com/p/c88260adaf5e" target="_blank" rel="external">http://www.jianshu.com/p/c88260adaf5e</a>  </p>
</blockquote>
<p><strong>该系列其它文章</strong><br><a href="http://ocnyang.com/2016/10/11/Gson_Guide1/">Gson使用指南（一）</a><br><a href="http://ocnyang.com/2016/10/11/Gson_Guide2/">Gson使用指南（二）</a><br><a href="http://ocnyang.com/2016/10/11/Gson_Guide3/">Gson使用指南（三）</a><br><a href="http://ocnyang.com/2016/10/11/Gson_Guide4/">Gson使用指南（四）</a>  </p>
<blockquote>
<p>注：此系列基于Gson 2.4。</p>
</blockquote>
<p>上一篇文章 <a href="http://ocnyang.com/2016/10/11/Gson_Guide1/">Gson使用指南（一）</a> 我们了解了Gson的基础用法，这次我们继续深入了解Gson的使用方法。</p>
<p><strong>本次的主要内容：</strong> </p>
<ul>
<li>Gson的流式反序列化</li>
<li>Gson的流式序列化<br>*　使用GsonBuilder导出null值、格式化输出、日期时间及其它小功能　　
　<h2 id="一、Gson的流式反序列化"><a href="#一、Gson的流式反序列化" class="headerlink" title="一、Gson的流式反序列化"></a>一、Gson的流式反序列化</h2></li>
</ul>
<h3 id="自动方式"><a href="#自动方式" class="headerlink" title="自动方式"></a>自动方式</h3><blockquote>
<p>Gson提供了fromJson()和toJson() 两个直接用于解析和生成的方法，前者实现反序列化，后者实现了序列化。同时每个方法都提供了重载方法，我常用的总共有5个。  </p>
</blockquote>
<p>这是我在上一篇文章开头说的，但我到最后也一直没有是哪5个，这次我给列出来之后，你就知道这次讲的是哪个了。</p>
<pre><code>Gson.toJson(Object);
Gson.fromJson(Reader,Class);
Gson.fromJson(String,Class);
Gson.fromJson(Reader,Type);
Gson.fromJson(String,Type);  
</code></pre><p>好了，本节结束！</p>
<h3 id="手动方式"><a href="#手动方式" class="headerlink" title="手动方式"></a>手动方式</h3><p>手动的方式就是使用stream包下的JsonReader类来手动实现反序列化，和Android中使用pull解析XML是比较类似的。</p>
<pre><code>String json = &quot;{\&quot;name\&quot;:\&quot;怪盗kidou\&quot;,\&quot;age\&quot;:\&quot;24\&quot;}&quot;;
User user = new User();
JsonReader reader = new JsonReader(new StringReader(json));
reader.beginObject(); // throws IOException
while (reader.hasNext()) {
    String s = reader.nextName();
    switch (s) {
        case &quot;name&quot;:
            user.name = reader.nextString();
            break;
        case &quot;age&quot;:
            user.age = reader.nextInt(); //自动转换
            break;
        case &quot;email&quot;:
            user.email = reader.nextString();
            break;
    }
}
reader.endObject(); // throws IOException
System.out.println(user.name);  // 怪盗kidou
System.out.println(user.age);   // 24
System.out.println(user.email); // ikidou@example.com  
</code></pre><p>其实自动方式最终都是通过JsonReader来实现的，如果第一个参数是String类型，那么Gson会创建一个StringReader转换成流操作。</p>
<p><img src="http://obbu6r1mi.bkt.clouddn.com/gson/gson_guide2_1.png" alt="Gson流式解析">  </p>
<h2 id="二、Gson的流式序列化"><a href="#二、Gson的流式序列化" class="headerlink" title="二、Gson的流式序列化"></a>二、Gson的流式序列化</h2><h3 id="自动方式-1"><a href="#自动方式-1" class="headerlink" title="自动方式"></a>自动方式</h3><p><img src="http://obbu6r1mi.bkt.clouddn.com/gson/gson_guide2_2.png" alt="Gson.toJson方法列表">  </p>
<p>所以啊，学会利用IDE的自动完成是多么重要这下知道了吧！<br>可以看出用红框选中的部分就是我们要找的东西。  </p>
<p>提示：OutputStream和Writer都实现了Appendable接口。  </p>
<pre><code>Gson gson = new Gson();
User user = new User(&quot;怪盗kidou&quot;,24,&quot;ikidou@example.com&quot;);
gson.toJson(user,System.out); // 写到控制台  
</code></pre><h3 id="手动方式-1"><a href="#手动方式-1" class="headerlink" title="手动方式"></a>手动方式</h3><pre><code>JsonWriter writer = new JsonWriter(new OutputStreamWriter(System.out));
writer.beginObject() // throws IOException
        .name(&quot;name&quot;).value(&quot;怪盗kidou&quot;)
        .name(&quot;age&quot;).value(24)
        .name(&quot;email&quot;).nullValue() //演示null
        .endObject(); // throws IOException
writer.flush(); // throws IOException
//{&quot;name&quot;:&quot;怪盗kidou&quot;,&quot;age&quot;:24,&quot;email&quot;:null}  
</code></pre><p>提示：除了beginObject、endObject还有beginArray和endArray，两者可以相互嵌套，注意配对即可。beginArray后不可以调用name方法，同样beginObject后在调用value之前必须要调用name方法。</p>
<h2 id="三、-使用GsonBuilder导出null值、格式化输出、日期时间"><a href="#三、-使用GsonBuilder导出null值、格式化输出、日期时间" class="headerlink" title="三、 使用GsonBuilder导出null值、格式化输出、日期时间"></a>三、 使用GsonBuilder导出null值、格式化输出、日期时间</h2><p>一般情况下Gson类提供的 API已经能满足大部分的使用场景，但我们需要更多更特殊、更强大的功能时，这时候就引入一个新的类 GsonBuilder。</p>
<p>GsonBuilder从名上也能知道是用于构建Gson实例的一个类，要想改变Gson默认的设置必须使用该类配置Gson。</p>
<h3 id="GsonBuilder用法"><a href="#GsonBuilder用法" class="headerlink" title="GsonBuilder用法"></a>GsonBuilder用法</h3><pre><code>Gson gson = new GsonBuilder()
               //各种配置
               .create(); //生成配置好的Gson  
</code></pre><p>Gson在默认情况下是不动导出值null的键的，如：</p>
<pre><code>public class User {
    //省略其它
    public String name;
    public int age;
    public String email;
}
Gson gson = new Gson();
User user = new User(&quot;怪盗kidou&quot;,24);
System.out.println(gson.toJson(user)); //{&quot;name&quot;:&quot;怪盗kidou&quot;,&quot;age&quot;:24}  
</code></pre><p>可以看出，email字段是没有在json中出现的，当我们在调试是、需要导出完整的json串时或API接中要求没有值必须用Null时，就会比较有用。</p>
<p>使用方法：</p>
<pre><code>Gson gson = new GsonBuilder()
        .serializeNulls()
        .create();
User user = new User(&quot;怪盗kidou&quot;, 24);
System.out.println(gson.toJson(user)); //{&quot;name&quot;:&quot;怪盗kidou&quot;,&quot;age&quot;:24,&quot;email&quot;:null}  
</code></pre><h3 id="格式化输出、日期时间及其它："><a href="#格式化输出、日期时间及其它：" class="headerlink" title="格式化输出、日期时间及其它："></a>格式化输出、日期时间及其它：</h3><p>这些都比较简单就不一一分开写了。</p>
<pre><code>Gson gson = new GsonBuilder()
        //序列化null
        .serializeNulls()
        // 设置日期时间格式，另有2个重载方法
        // 在序列化和反序化时均生效
        .setDateFormat(&quot;yyyy-MM-dd&quot;)
        // 禁此序列化内部类
        .disableInnerClassSerialization()
        //生成不可执行的Json（多了 )]}&apos; 这4个字符）
        .generateNonExecutableJson()
        //禁止转义html标签
        .disableHtmlEscaping()
        //格式化输出
        .setPrettyPrinting()
        .create();  
</code></pre><p>注意：内部类(Inner Class)和嵌套类(Nested Class)的区别</p>
<p>这次文章就到这里，欢迎提问互动，如有不对的地方请指正。</p>
<h2 id="下篇文章内容提要"><a href="#下篇文章内容提要" class="headerlink" title="下篇文章内容提要"></a>下篇文章内容提要</h2><ul>
<li><p>字段过滤的几种方法  </p>
<ul>
<li>基于@Expose注解</li>
<li>基于访问修饰符</li>
<li>基于版本</li>
<li>自定义规则  </li>
</ul>
</li>
<li><p>POJO与JSON的字段映射规则</p>
</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://ocnyang.com/2016/10/11/Gson_Guide1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="OCN.Yang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/ocnyang.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="杨欧神/OCN.Yang">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/10/11/Gson_Guide1/" itemprop="url">
                  Gson使用指南（一）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-10-11T09:03:15+08:00">
                2016-10-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/第三方框架/" itemprop="url" rel="index">
                    <span itemprop="name">第三方框架</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2016/10/11/Gson_Guide1/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/10/11/Gson_Guide1/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2016/10/11/Gson_Guide1/" class="leancloud_visitors" data-flag-title="Gson使用指南（一）">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Gson使用指南（一）"><a href="#Gson使用指南（一）" class="headerlink" title="Gson使用指南（一）"></a>Gson使用指南（一）</h1><blockquote>
<p>原文链接：<a href="http://www.jianshu.com/p/e740196225a4" target="_blank" rel="external">http://www.jianshu.com/p/e740196225a4</a>  </p>
</blockquote>
<p>JSON (<a href="http://json.org/json-zh.html" target="_blank" rel="external">官网</a>) 是一种文本形式的数据交换格式，它比XML更轻量、比二进制容易阅读和编写，调式也更加方便。其重要性不言而喻。解析和生成的方式很多，Java中最常用的类库有：JSON-Java、Gson、Jackson、FastJson等。  </p>
<p><strong>该系列其它文章</strong><br><a href="http://ocnyang.com/2016/10/11/Gson_Guide1/">Gson使用指南（一）</a><br><a href="http://ocnyang.com/2016/10/11/Gson_Guide2/">Gson使用指南（二）</a><br><a href="http://ocnyang.com/2016/10/11/Gson_Guide3/">Gson使用指南（三）</a><br><a href="http://ocnyang.com/2016/10/11/Gson_Guide4/">Gson使用指南（四）</a>  </p>
<blockquote>
<p>注：此系列基于Gson 2.4。</p>
</blockquote>
<p><strong>本篇文章的主要内容：</strong></p>
<ul>
<li>Gson的基本用法</li>
<li>属性重命名 @SerializedName 注解的使用</li>
<li>Gson中使用泛型  </li>
</ul>
<h2 id="一、Gson的基本用法"><a href="#一、Gson的基本用法" class="headerlink" title="一、Gson的基本用法"></a>一、Gson的基本用法</h2><p>Gson提供了fromJson() 和toJson() 两个直接用于解析和生成的方法，前者实现反序列化，后者实现了序列化。同时每个方法都提供了重载方法，我常用的总共有5个。  </p>
<h3 id="基本数据类型的解析"><a href="#基本数据类型的解析" class="headerlink" title="基本数据类型的解析"></a>基本数据类型的解析</h3><pre><code>Gson gson = new Gson();
int i = gson.fromJson(&quot;100&quot;, int.class);              //100
double d = gson.fromJson(&quot;\&quot;99.99\&quot;&quot;, double.class);  //99.99
boolean b = gson.fromJson(&quot;true&quot;, boolean.class);     // true
String str = gson.fromJson(&quot;String&quot;, String.class);   // String  
</code></pre><blockquote>
<p>注：不知道你是否注意到了第2、3行有什么不一样没</p>
</blockquote>
<h3 id="基本数据类型的生成"><a href="#基本数据类型的生成" class="headerlink" title="基本数据类型的生成"></a>基本数据类型的生成</h3><pre><code>Gson gson = new Gson();
String jsonNumber = gson.toJson(100);       // 100
String jsonBoolean = gson.toJson(false);    // false
String jsonString = gson.toJson(&quot;String&quot;); //&quot;String&quot;  
</code></pre><h3 id="POJO类的生成与解析"><a href="#POJO类的生成与解析" class="headerlink" title="POJO类的生成与解析"></a>POJO类的生成与解析</h3><pre><code>public class User {
    //省略其它
    public String name;
    public int age;
    public String emailAddress;
}  
</code></pre><p>生成JSON：</p>
<pre><code>Gson gson = new Gson();
User user = new User(&quot;怪盗kidou&quot;,24);
String jsonObject = gson.toJson(user); // {&quot;name&quot;:&quot;怪盗kidou&quot;,&quot;age&quot;:24}  
</code></pre><p>解析JSON：</p>
<pre><code>Gson gson = new Gson();
String jsonString = &quot;{\&quot;name\&quot;:\&quot;怪盗kidou\&quot;,\&quot;age\&quot;:24}&quot;;
User user = gson.fromJson(jsonString, User.class);  
</code></pre><h2 id="二、属性重命名-SerializedName-注解的使用"><a href="#二、属性重命名-SerializedName-注解的使用" class="headerlink" title="二、属性重命名 @SerializedName 注解的使用"></a>二、属性重命名 @SerializedName 注解的使用</h2><p>从上面POJO的生成与解析可以看出json的字段和值是的名称和类型是一一对应的，但也有一定容错机制(如第一个例子第3行将字符串的99.99转成double型，你可别告诉我都是字符串啊)，但有时候也会出现一些不和谐的情况，如：<br>期望的json格式</p>
<pre><code>{&quot;name&quot;:&quot;怪盗kidou&quot;,&quot;age&quot;:24,&quot;emailAddress&quot;:&quot;ikidou@example.com&quot;}  
</code></pre><p>实际</p>
<pre><code>{&quot;name&quot;:&quot;怪盗kidou&quot;,&quot;age&quot;:24,&quot;email_address&quot;:&quot;ikidou@example.com&quot;}  
</code></pre><p>这对于使用PHP作为后台开发语言时很常见的情况，php和js在命名时一般采用下划线风格，而Java中一般采用的驼峰法，让后台的哥们改吧 前端和后台都不爽，但要自己使用下划线风格时我会感到不适应，怎么办?难到没有两全齐美的方法么?  </p>
<p>我们知道Gson在序列化和反序列化时需要使用反射，说到反射就不得不想到注解,一般各类库都将注解放到annotations包下，打开源码在com.google.gson包下果然有一个annotations，里面有一个SerializedName的注解类，这应该就是我们要找的。  </p>
<p>那么对于json中email_address这个属性对应POJO的属性则变成：  </p>
<pre><code>@SerializedName(&quot;email_address&quot;)
public String emailAddress;  
</code></pre><p>这样的话，很好的保留了前端、后台、Android/java各自的命名习惯。  </p>
<p>你以为这样就完了么?  </p>
<p>如果接中设计不严谨或者其它地方可以重用该类，其它字段都一样，就emailAddress 字段不一样，比如有下面三种情况那怎么?重新写一个?   </p>
<pre><code>{&quot;name&quot;:&quot;怪盗kidou&quot;,&quot;age&quot;:24,&quot;emailAddress&quot;:&quot;ikidou@example.com&quot;}
{&quot;name&quot;:&quot;怪盗kidou&quot;,&quot;age&quot;:24,&quot;email_address&quot;:&quot;ikidou@example.com&quot;}
{&quot;name&quot;:&quot;怪盗kidou&quot;,&quot;age&quot;:24,&quot;email&quot;:&quot;ikidou@example.com&quot;}  
</code></pre><h3 id="为POJO字段提供备选属性名"><a href="#为POJO字段提供备选属性名" class="headerlink" title="为POJO字段提供备选属性名"></a>为POJO字段提供备选属性名</h3><p>SerializedName注解提供了两个属性，上面用到了其中一个，别外还有一个属性alternate，接收一个String数组。  </p>
<blockquote>
<p>注：alternate需要2.4版本</p>
</blockquote>
<pre><code>@SerializedName(value = &quot;emailAddress&quot;, alternate = {&quot;email&quot;, &quot;email_address&quot;})
public String emailAddress;  
</code></pre><p>当上面的三个属性(email_address、email、emailAddress)都中出现任意一个时均可以得到正确的结果。  </p>
<blockquote>
<p>注：当多种情况同时出时，以最后一个出现的值为准。  </p>
</blockquote>
<pre><code>Gson gson = new Gson();
String json = &quot;{\&quot;name\&quot;:\&quot;怪盗kidou\&quot;,\&quot;age\&quot;:24,\&quot;emailAddress\&quot;:\&quot;ikidou_1@example.com\&quot;,\&quot;email\&quot;:\&quot;ikidou_2@example.com\&quot;,\&quot;email_address\&quot;:\&quot;ikidou_3@example.com\&quot;}&quot;;
User user = gson.fromJson(json, User.class);
System.out.println(user.emailAddress); // ikidou_3@example.com  
</code></pre><h2 id="三、Gson中使用泛型"><a href="#三、Gson中使用泛型" class="headerlink" title="三、Gson中使用泛型"></a>三、Gson中使用泛型</h2><p>上面了解的JSON中的Number、boolean、Object和String，现在说一下Array。  </p>
<p>例：JSON字符串数组</p>
<pre><code>[&quot;Android&quot;,&quot;Java&quot;,&quot;PHP&quot;]  
</code></pre><p>当我们要通过Gson解析这个json时，一般有两种方式：使用数组，使用List。而List对于增删都是比较方便的，所以实际使用是还是List比较多。</p>
<p>数组比较简单</p>
<pre><code>Gson gson = new Gson();
String jsonArray = &quot;[\&quot;Android\&quot;,\&quot;Java\&quot;,\&quot;PHP\&quot;]&quot;;
String[] strings = gson.fromJson(jsonArray, String[].class);  
</code></pre><p>但对于List将上面的代码中的 String[].class 直接改为 List<string>.class 是行不通的。对于Java来说List<string> 和List<user> 这俩个的字节码文件只一个那就是List.class，这是Java泛型使用时要注意的问题 泛型擦除。</user></string></string></p>
<p>为了解决的上面的问题，Gson为我们提供了TypeToken来实现对泛型的支持，所以当我们希望使用将以上的数据解析为List<string>时需要这样写。</string></p>
<pre><code>Gson gson = new Gson();
String jsonArray = &quot;[\&quot;Android\&quot;,\&quot;Java\&quot;,\&quot;PHP\&quot;]&quot;;
String[] strings = gson.fromJson(jsonArray, String[].class);
List&lt;String&gt; stringList = gson.fromJson(jsonArray, new TypeToken&lt;List&lt;String&gt;&gt;() {}.getType());  
</code></pre><blockquote>
<p>注：TypeToken的构造方法是protected修饰的,所以上面才会写成new TypeToken<list<string>&gt;() {}.getType() 而不是  new TypeToken<list<string>&gt;().getType()</list<string></list<string></p>
</blockquote>
<h3 id="泛型解析对接口POJO的设计影响"><a href="#泛型解析对接口POJO的设计影响" class="headerlink" title="泛型解析对接口POJO的设计影响"></a>泛型解析对接口POJO的设计影响</h3><p>泛型的引入可以减少无关的代码，如我现在所在公司接口返回的数据分为两类：</p>
<pre><code>{&quot;code&quot;:&quot;0&quot;,&quot;message&quot;:&quot;success&quot;,&quot;data&quot;:{}}  

{&quot;code&quot;:&quot;0&quot;,&quot;message&quot;:&quot;success&quot;,&quot;data&quot;:[]}  
</code></pre><p>我们真正需要的data所包含的数据，而code只使用一次，message则几乎不用。如果Gson不支持泛型或不知道Gson支持泛型的同学一定会这么定义POJO。</p>
<pre><code>public class UserResponse {
    public int code;
    public String message;
    public User data;
}  
</code></pre><p>当其它接口的时候又重新定义一个XXResponse将data的类型改成XX，很明显code，和message被重复定义了多次，通过泛型的话我们可以将code和message字段抽取到一个Result的类中，这样我们只需要编写data字段所对应的POJO即可，更专注于我们的业务逻辑。如：</p>
<pre><code>public class Result&lt;T&gt; {
    public int code;
    public String message;
    public T data;
}  
</code></pre><p>那么对于data字段是User时则可以写为 Result<user> ,当是个列表的时候为 Result<list<user>&gt;，其它同理。</list<user></user></p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本文主要通过代码向各位读者讲解了Gson的基本用法，以后还会更新更多更高级的用法，如果你还不熟悉 <strong>注解</strong>和<strong>泛型</strong> 那么你要多多努力啦。</p>
<p>如果你有其它的想了解的内容(不限于Gson)请给我留言评论，水平有限，欢迎拍砖。</p>
<h2 id="4月6日补充"><a href="#4月6日补充" class="headerlink" title="4月6日补充"></a>4月6日补充</h2><p>有说看不懂Result那段怎么个简化法，下面给个两个完整的例子，User和List<user> 。</user></p>
<p>没有引入泛型之前时写法：</p>
<pre><code>public class UserResult {
    public int code;
    public String message;
    public User data;
}
//=========
public class UserListResult {
    public int code;
    public String message;
    public List&lt;User&gt; data;
}
//=========
String json = &quot;{..........}&quot;;
Gson gson = new Gson();
UserResult userResult = gson.fromJson(json,UserResult.class);
User user = userResult.data;

UserListResult userListResult = gson.fromJson(json,UserListResult.class);
List&lt;User&gt; users = userListResult.data;  
</code></pre><p>上面有两个类UserResult和UserListResult，有两个字段重复，一两个接口就算了，如果有上百个怎么办?不得累死?所以引入泛型。</p>
<pre><code>//不再重复定义Result类
Type userType = new TypeToken&lt;Result&lt;User&gt;&gt;(){}.getType();
Result&lt;User&gt; userResult = gson.fromJson(json,userType);
User user = userResult.data;

Type userListType = new TypeToken&lt;Result&lt;List&lt;User&gt;&gt;&gt;(){}.getType();
Result&lt;List&lt;User&gt;&gt; userListResult = gson.fromJson(json,userListType);
List&lt;User&gt; users = userListResult.data;  
</code></pre><p>看出区别了么?引入了泛型之后虽然要多写一句话用于获取泛型信息，但是返回值类型很直观，也少定义了很多无关类。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://ocnyang.com/2016/10/10/Retrofit2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="OCN.Yang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/ocnyang.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="杨欧神/OCN.Yang">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/10/10/Retrofit2/" itemprop="url">
                  Retrofit2完全教程
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-10-10T18:03:15+08:00">
                2016-10-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/第三方框架/" itemprop="url" rel="index">
                    <span itemprop="name">第三方框架</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2016/10/10/Retrofit2/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/10/10/Retrofit2/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2016/10/10/Retrofit2/" class="leancloud_visitors" data-flag-title="Retrofit2完全教程">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Retrofit2完全教程"><a href="#Retrofit2完全教程" class="headerlink" title="Retrofit2完全教程"></a>Retrofit2完全教程</h1><blockquote>
<p>作者： @怪盗kidou<br>Retrofit版本: 2.0.2  </p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文中的Retrofit均指代Retrofit2.0。<br>本文涉及到的代码以及测试使用的接口可在<a href="https://github.com/ikidou/Retrofit2Demo" target="_blank" rel="external">Github</a>上找到。<br>测试接口服务器在 server 项目下，直接运行 RESTServer.main() 即可启动测试服务器，所面代码示例均使用该接口(接口地址 <a href="http://localhost:4567/" target="_blank" rel="external">http://localhost:4567/</a> ).<br>当然你也可以自己借助 <a href="https://github.com/typicode/json-server" target="_blank" rel="external">json-server</a> 或 最新开源的Parse 搭建一个REST API，不过都需要安装Node.js，有兴趣的可以去试试。  </p>
<p>接口列表：  </p>
<p><img src="http://obbu6r1mi.bkt.clouddn.com/retrofit2/retrofit1.png" alt="">  </p>
<p>注：以上的接口的{id}和{page}均代表一个纯数字，/blog/{id} 可以用 /blog?id=XXX 代替，page同理。</p>
<p>前面写了<a href="http://www.jianshu.com/p/e544b7a76dac" target="_blank" rel="external">你应该知道的HTTP基础知识</a> 介绍了HTTP的相关知识，不知道那些想了解Retrofit的同鞋是不是去看了<a href="http://square.github.io/retrofit/" target="_blank" rel="external">Retrofit的官方教程</a>，曾经我在你真的会用Gson吗?<a href="http://www.jianshu.com/p/3108f1e44155" target="_blank" rel="external">Gson使用指南（四）</a> 中说当你了解了注解、反射、泛型、HTTP的内容只需要看一篇Retrofit的代码示例就可以轻松玩转Retrofit，不知道你玩转了没?<br>当然注解、反射、泛型的内容还没有写，Retrofit的内容却先来了！毕竟看懂Retrofit也只需要会使就行，你准备好了吗？  </p>
<h2 id="1、Retrofit入门"><a href="#1、Retrofit入门" class="headerlink" title="1、Retrofit入门"></a>1、Retrofit入门</h2><p>Retrofit 其实相当简单，简单到源码只有37个文件，其中22个文件是注解还都和HTTP有关，真正暴露给用户的类并不多,所以我看了一遍 官方教程 大多数情景就可以无障碍使用，如果你还没有看过，可以先去看看,虽然是英文，但代码才是最好的教程不是么?当然本篇文章会介绍得详细一点，不能写一篇水文。</p>
<h3 id="1-1、创建Retrofit实例"><a href="#1-1、创建Retrofit实例" class="headerlink" title="1.1、创建Retrofit实例"></a>1.1、创建Retrofit实例</h3><pre><code>Retrofit retrofit = new Retrofit.Builder()
        .baseUrl(&quot;http://localhost:4567/&quot;)
        .build();  
</code></pre><p>创建Retrofit实例时需要通过Retrofit.Builder,并调用baseUrl方法设置URL。  </p>
<blockquote>
<p>注： Retrofit2 的baseUlr 必须以 /（斜线） 结束，不然会抛出一个IllegalArgumentException,所以如果你看到别的教程没有以 / 结束，那么多半是直接从Retrofit 1.X 照搬过来的。  </p>
</blockquote>
<h3 id="1-2、接口定义"><a href="#1-2、接口定义" class="headerlink" title="1.2、接口定义"></a>1.2、接口定义</h3><p>以获取指定id的Blog为例:  </p>
<pre><code>public interface BlogService {
    @GET(&quot;blog/{id}&quot;)
    Call&lt;ResponseBody&gt; getFirstBlog(@Path(&quot;id&quot;) int id);
}  
</code></pre><p>注意，这里是interface不是class，所以我们是无法直接调用该方法，我们需要用Retrofit创建一个BlogService的代理对象。  </p>
<pre><code>BlogService service = retrofit.create(BlogService.class);  
</code></pre><p>拿到代理对象之后，就可以调用该方法啦。  </p>
<h3 id="1-3、接口调用"><a href="#1-3、接口调用" class="headerlink" title="1.3、接口调用"></a>1.3、接口调用</h3><pre><code>Call&lt;ResponseBody&gt; call = service.getFirstBlog(2);
// 用法和OkHttp的call如出一辙,
// 不同的是如果是Android系统回调方法执行在主线程
call.enqueue(new Callback&lt;ResponseBody&gt;() {
    @Override
    public void onResponse(Call&lt;ResponseBody&gt; call, Response&lt;ResponseBody&gt; response) {
        try {
            System.out.println(response.body().string());
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    @Override
    public void onFailure(Call&lt;ResponseBody&gt; call, Throwable t) {
        t.printStackTrace();
    }
});  
</code></pre><p>打印结果:  </p>
<pre><code>{
  &quot;code&quot;: 200,
  &quot;msg&quot;: &quot;OK&quot;,
  &quot;data&quot;: {
    &quot;id&quot;: 2,
    &quot;date&quot;: &quot;2016-04-15 03:17:50&quot;,
    &quot;author&quot;: &quot;怪盗kidou&quot;,
    &quot;title&quot;: &quot;Retrofit2 测试2&quot;,
    &quot;content&quot;: &quot;这里是 Retrofit2 Demo 测试服务器2&quot;
  },
  &quot;count&quot;: 0,
  &quot;page&quot;: 0
}   
</code></pre><p>示例源码见 <a href="https://github.com/ikidou/Retrofit2Demo/blob/master/client/src/main/java/com/github/ikidou/Example01.java" target="_blank" rel="external">Example01.java</a>  </p>
<h2 id="2、Retrofit注解详解"><a href="#2、Retrofit注解详解" class="headerlink" title="2、Retrofit注解详解"></a>2、Retrofit注解详解</h2><p>上面提到Retrofit 共22个注解，这节就专门介绍这22个注解，为帮助大家更好理解我将这22个注解分为三类，并用表格的形式展现出来,表格上说得并不完整，具体的见源码上的例子注释。  </p>
<h3 id="第一类：HTTP请求方法"><a href="#第一类：HTTP请求方法" class="headerlink" title="第一类：HTTP请求方法"></a>第一类：HTTP请求方法</h3><p><img src="http://obbu6r1mi.bkt.clouddn.com/retrofit2/retrofit2.png" alt="HTTP请求方法注解"></p>
<p>以上表格中的除HTTP以外都对应了HTTP标准中的请求方法，而HTTP注解则可以代替以上方法中的任意一个注解,有3个属性：method、path,hasBody,下面是用HTTP注解实现上面 Example01.java 的例子。</p>
<pre><code>public interface BlogService {
    /**
     * method 表示请的方法，不区分大小写
     * path表示路径
     * hasBody表示是否有请求体
     */
    @HTTP(method = &quot;get&quot;, path = &quot;blog/{id}&quot;, hasBody = false)
    Call&lt;ResponseBody&gt; getFirstBlog(@Path(&quot;id&quot;) int id);
}  
</code></pre><p>示例源码见 <a href="https://github.com/ikidou/Retrofit2Demo/blob/master/client/src/main/java/com/github/ikidou/Example02.java" target="_blank" rel="external">Example02.java</a>  </p>
<h3 id="第二类：标记类"><a href="#第二类：标记类" class="headerlink" title="第二类：标记类"></a>第二类：标记类</h3><p><img src="http://obbu6r1mi.bkt.clouddn.com/retrofit2/retrofit3.png" alt="标记类注解"></p>
<p>示例源码见 <a href="https://github.com/ikidou/Retrofit2Demo/blob/master/client/src/main/java/com/github/ikidou/Example03.java" target="_blank" rel="external">Example03.java</a>  </p>
<h3 id="第三类：参数类"><a href="#第三类：参数类" class="headerlink" title="第三类：参数类"></a>第三类：参数类</h3><p><img src="http://obbu6r1mi.bkt.clouddn.com/retrofit2/retrofit4.png" alt="参数类注解">  </p>
<p><strong>注1：</strong>{占位符}和PATH尽量只用在URL的path部分，url中的参数使用Query和QueryMap 代替，保证接口定义的简洁<br><strong>注2：</strong>Query、Field和Part这三者都支持数组和实现了Iterable接口的类型，如List，Set等，方便向后台传递数组。  </p>
<pre><code>Call&lt;ResponseBody&gt; foo(@Query(&quot;ids[]&quot;) List&lt;Integer&gt; ids);
//结果：ids[]=0&amp;ids[]=1&amp;ids[]=2  
</code></pre><p>Path 示例源码见 Example01.java<br>Field、FieldMap、Part和PartMap 示例源码见 Example03.java<br>Header和Headers 示例源码见 <a href="https://github.com/ikidou/Retrofit2Demo/blob/master/client/src/main/java/com/github/ikidou/Example04.java" target="_blank" rel="external">Example04.java</a><br>Query、QueryMap、Url 示例源码见 <a href="https://github.com/ikidou/Retrofit2Demo/blob/master/client/src/main/java/com/github/ikidou/Example05.java" target="_blank" rel="external">Example05.java</a>  </p>
<h2 id="3、Gson与Converter"><a href="#3、Gson与Converter" class="headerlink" title="3、Gson与Converter"></a>3、Gson与Converter</h2><p>在默认情况下Retrofit只支持将HTTP的响应体转换换为ResponseBody,<br>这也是什么我在前面的例子接口的返回值都是 Call<responsebody>，<br>但如果响应体只是支持转换为ResponseBody的话何必要引用泛型呢，<br>返回值直接用一个Call就行了嘛，既然支持泛型，那说明泛型参数可以是其它类型的，<br>而Converter就是Retrofit为我们提供用于将ResponseBody转换为我们想要的类型，<br>有了Converter之后我们就可以写把我们的第一个例子的接口写成这个样子了：</responsebody></p>
<pre><code>public interface BlogService {
  @GET(&quot;blog/{id}&quot;) //这里的{id} 表示是一个变量
  Call&lt;Result&lt;Blog&gt;&gt; getFirstBlog(/** 这里的id表示的是上面的{id} */@Path(&quot;id&quot;) int id);
}  
</code></pre><p>当然只改变泛型的类型是不行的，我们在创建Retrofit时需要明确告知用于将ResponseBody转换我们泛型中的类型时需要使用的Converter  </p>
<p>引入Gson支持:  </p>
<pre><code>compile &apos;com.squareup.retrofit2:converter-gson:2.0.2&apos;  
</code></pre><p>通过GsonConverterFactory为Retrofit添加Gson支持：</p>
<pre><code>Gson gson = new GsonBuilder()
      //配置你的Gson
      .setDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;)
      .create();

Retrofit retrofit = new Retrofit.Builder()
      .baseUrl(&quot;http://localhost:4567/&quot;)
      //可以接收自定义的Gson，当然也可以不传
      .addConverterFactory(GsonConverterFactory.create(gson))
      .build();  
</code></pre><p>示例源码见 <a href="https://github.com/ikidou/Retrofit2Demo/blob/master/client/src/main/java/com/github/ikidou/Example06.java" target="_blank" rel="external">Example06.java</a>  </p>
<p>这样Retrofit就会使用Gson将ResponseBody转换我们想要的类型。  </p>
<p>这是时候我们终于可以演示如使创建一个Blog了！  </p>
<pre><code>@POST(&quot;blog&quot;)
Call&lt;Result&lt;Blog&gt;&gt; createBlog(@Body Blog blog);  
</code></pre><p>被@Body注解的的Blog将会被Gson转换成RequestBody发送到服务器。  </p>
<pre><code>BlogService service = retrofit.create(BlogService.class);
Blog blog = new Blog();
blog.content = &quot;新建的Blog&quot;;
blog.title = &quot;测试&quot;;
blog.author = &quot;怪盗kidou&quot;;
Call&lt;Result&lt;Blog&gt;&gt; call = service.createBlog(blog);  
</code></pre><p>结果：  </p>
<pre><code>Result{
  code=200,
  msg=&apos;OK&apos;,
  data=Blog{
    id=20,
    date=&apos;2016-04-21 05:29:58&apos;,
    author=&apos;怪盗kidou&apos;,
    title=&apos;测试&apos;,
    content=&apos;新建的Blog&apos;
  },
  count=0,
  page=0
}  
</code></pre><p>示例源码见 (Example07.java)[<a href="https://github.com/ikidou/Retrofit2Demo/blob/master/client/src/main/java/com/github/ikidou/Example07.java" target="_blank" rel="external">https://github.com/ikidou/Retrofit2Demo/blob/master/client/src/main/java/com/github/ikidou/Example07.java</a>]  </p>
<p>如果你对Gson不熟悉可以参考我写的<a href="http://www.jianshu.com/p/e740196225a4" target="_blank" rel="external">《你真的会用Gson吗?Gson使用指南》</a> 系列。</p>
<h2 id="4、RxJava与CallAdapter"><a href="#4、RxJava与CallAdapter" class="headerlink" title="4、RxJava与CallAdapter"></a>4、RxJava与CallAdapter</h2><p>说到Retrofit就不得说到另一个火到不行的库RxJava，网上已经不少文章讲如何与Retrofit结合，但这里还是会有一个RxJava的例子，不过这里主要目的是介绍使用CallAdapter所带来的效果。  </p>
<p>第3节介绍的Converter是对于Call<t>中T的转换，而CallAdapter则可以对Call转换，这样的话Call<t>中的Call也是可以被替换的，而返回值的类型就决定你后续的处理程序逻辑，同样Retrofit提供了多个CallAdapter，这里以RxJava的为例，用Observable代替Call：  </t></t></p>
<p>引入RxJava支持:  </p>
<pre><code>compile &apos;com.squareup.retrofit2:adapter-rxjava:2.0.2&apos;  
</code></pre><p>通过RxJavaCallAdapterFactory为Retrofit添加RxJava支持：  </p>
<pre><code>Retrofit retrofit = new Retrofit.Builder()
      .baseUrl(&quot;http://localhost:4567/&quot;)
      .addConverterFactory(GsonConverterFactory.create())
      .addCallAdapterFactory(RxJavaCallAdapterFactory.create())
      .build();  
</code></pre><p>接口设计：  </p>
<pre><code>public interface BlogService {
  @POST(&quot;/blog&quot;)
  Observable&lt;Result&lt;List&lt;Blog&gt;&gt;&gt; getBlogs();
}  
</code></pre><p>使用：  </p>
<pre><code>BlogService service = retrofit.create(BlogService.class);
service.getBlogs(1)
  .subscribeOn(Schedulers.io())
  .subscribe(new Subscriber&lt;Result&lt;List&lt;Blog&gt;&gt;&gt;() {
      @Override
      public void onCompleted() {
        System.out.println(&quot;onCompleted&quot;);
      }

      @Override
      public void onError(Throwable e) {
        System.err.println(&quot;onError&quot;);
      }

      @Override
      public void onNext(Result&lt;List&lt;Blog&gt;&gt; blogsResult) {
        System.out.println(blogsResult);
      }
  });  
</code></pre><p>结果：</p>
<pre><code>Result{
  code=200,
  msg=&apos;OK&apos;,
  data=[
    Blog{
      id=1,
      date=&apos;2016-04-15 03:17:50&apos;,
      author=&apos;怪盗kidou&apos;,
      title=&apos;Retrofit2 测试1&apos;,
      content=&apos;这里是 Retrofit2 Demo 测试服务器1&apos;
    },
    .....
  ],
  count=20,
  page=1
}    
</code></pre><p>示例源码见 <a href="https://github.com/ikidou/Retrofit2Demo/blob/master/client/src/main/java/com/github/ikidou/Example08.java" target="_blank" rel="external">Example08.java</a>  </p>
<blockquote>
<p>「补充」：像上面的这种情况最后我们无法获取到返回的Header和响应码的，如果我们需要这两者，提供两种方案：  </p>
<ol>
<li>用Observable<response<t>&gt;``Observable<t> ,这里的Response指retrofit2.Response</t></response<t></li>
<li>用Observable<result<t>&gt; 代替Observable<t>，这里的Result是指retrofit2.adapter.rxjava.Result,这个Result中包含了Response的实例  </t></result<t></li>
</ol>
</blockquote>
<h2 id="5、自定义Converter"><a href="#5、自定义Converter" class="headerlink" title="5、自定义Converter"></a>5、自定义Converter</h2><p>本节的内容是教大家实现在一简易的Converter，这里以返回格式为Call<string>为例。  </string></p>
<p>在此之前先了解一下Converter接口及其作用：  </p>
<pre><code>public interface Converter&lt;F, T&gt; {
  // 实现从 F(rom) 到 T(o)的转换
  T convert(F value) throws IOException;

  // 用于向Retrofit提供相应Converter的工厂
  abstract class Factory {
    // 这里创建从ResponseBody其它类型的Converter，如果不能处理返回null
    // 主要用于对响应体的处理
    public Converter&lt;ResponseBody, ?&gt; responseBodyConverter(Type type, Annotation[] annotations,
    Retrofit retrofit) {
      return null;
    }

    // 在这里创建 从自定类型到ResponseBody 的Converter,不能处理就返回null，
    // 主要用于对Part、PartMap、Body注解的处理
    public Converter&lt;?, RequestBody&gt; requestBodyConverter(Type type,
    Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) {
      return null;
    }

    // 这里用于对Field、FieldMap、Header、Path、Query、QueryMap注解的处理
    // Retrfofit对于上面的几个注解默认使用的是调用toString方法
    public Converter&lt;?, String&gt; stringConverter(Type type, Annotation[] annotations,
    Retrofit retrofit) {
      return null;
    }

  }
}  
</code></pre><p>我们要想从Call<responsebody> 转换为 Call<string> 那么对应的F和T则分别对应ResponseBody和String，我们定义一个StringConverter并实现Converter接口。  </string></responsebody></p>
<pre><code>public static class StringConverter implements Converter&lt;ResponseBody, String&gt; {

  public static final StringConverter INSTANCE = new StringConverter();

  @Override
  public String convert(ResponseBody value) throws IOException {
    return value.string();
  }
}  
</code></pre><p>我们需要一个Fractory来向Retrofit注册StringConverter  </p>
<pre><code>public static class StringConverterFactory extends Converter.Factory {

  public static final StringConverterFactory INSTANCE = new StringConverterFactory();

  public static StringConverterFactory create() {
    return INSTANCE;
  }

  // 我们只关实现从ResponseBody 到 String 的转换，所以其它方法可不覆盖
  @Override
  public Converter&lt;ResponseBody, ?&gt; responseBodyConverter(Type type, Annotation[] annotations, Retrofit retrofit) {
    if (type == String.class) {
      return StringConverter.INSTANCE;
    }
    //其它类型我们不处理，返回null就行
    return null;
  }
}  
</code></pre><p>使用Retrofit.Builder.addConverterFactory向Retrofit注册我们StringConverterFactory：  </p>
<pre><code>Retrofit retrofit = new Retrofit.Builder()
      .baseUrl(&quot;http://localhost:4567/&quot;)
      // 如是有Gson这类的Converter 一定要放在其它前面
      .addConverterFactory(StringConverterFactory.create())
      .addConverterFactory(GsonConverterFactory.create())
      .build();  
</code></pre><p><strong>注：</strong>addConverterFactory是有先后顺序的，如果有多个ConverterFactory都支持同一种类型，那么就是只有第一个才会被使用，而GsonConverterFactory是不判断是否支持的，所以这里交换了顺序还会有一个异常抛出，原因是类型不匹配。   </p>
<p>只要返回值类型的泛型参数就会由我们的StringConverter处理,不管是Call<string>还是Observable<string>  </string></string></p>
<p>有没有很简单?如果你有其它的需求处理的就自己实现吧。  </p>
<p>示例源码见 <a href="https://github.com/ikidou/Retrofit2Demo/blob/master/client/src/main/java/com/github/ikidou/Example09.java" target="_blank" rel="external">Example09.java</a>  </p>
<h2 id="6、自定义CallAdapter"><a href="#6、自定义CallAdapter" class="headerlink" title="6、自定义CallAdapter"></a>6、自定义CallAdapter</h2><p>本节将介绍如何自定一个CallAdapter，并验证是否所有的String都会使用我们第5节中自定义的Converter。  </p>
<p>先看一下CallAdapter接口定义及各方法的作用：  </p>
<pre><code>public interface CallAdapter&lt;T&gt; {

  // 直正数据的类型 如Call&lt;T&gt; 中的 T
  // 这个 T 会作为Converter.Factory.responseBodyConverter 的第一个参数
  // 可以参照上面的自定义Converter
  Type responseType();

  &lt;R&gt; T adapt(Call&lt;R&gt; call);

  // 用于向Retrofit提供CallAdapter的工厂类
  abstract class Factory {
    // 在这个方法中判断是否是我们支持的类型，returnType 即Call&lt;Requestbody&gt;和`Observable&lt;Requestbody&gt;`
    // RxJavaCallAdapterFactory 就是判断returnType是不是Observable&lt;?&gt; 类型
    // 不支持时返回null
    public abstract CallAdapter&lt;?&gt; get(Type returnType, Annotation[] annotations,
    Retrofit retrofit);

    // 用于获取泛型的参数 如 Call&lt;Requestbody&gt; 中 Requestbody
    protected static Type getParameterUpperBound(int index, ParameterizedType type) {
      return Utils.getParameterUpperBound(index, type);
    }

    // 用于获取泛型的原始类型 如 Call&lt;Requestbody&gt; 中的 Call
    // 上面的get方法需要使用该方法。
    protected static Class&lt;?&gt; getRawType(Type type) {
      return Utils.getRawType(type);
    }
  }
}  
</code></pre><p>了解了CallAdapter的结构和其作用之后，我们就可以开始自定义我们的CallAdapter了，本节以CustomCall<string>为例。  </string></p>
<p>在此我们需要定义一个CustomCall，不过这里的CustomCall作为演示只是对Call的一个包装，并没有实际的用途。  </p>
<pre><code>public static class CustomCall&lt;R&gt; {

  public final Call&lt;R&gt; call;

  public CustomCall(Call&lt;R&gt; call) {
    this.call = call;
  }

  public R get() throws IOException {
    return call.execute().body();
  }
}  
</code></pre><p>有了CustomCall，我们还需要一个CustomCallAdapter来实现 Call<t> 到 CustomCall<t>的转换，这里需要注意的是最后的泛型，是我们要返回的类型。  </t></t></p>
<pre><code>public static class CustomCallAdapter implements CallAdapter&lt;CustomCall&lt;?&gt;&gt; {

  private final Type responseType;

  // 下面的 responseType 方法需要数据的类型
  CustomCallAdapter(Type responseType) {
    this.responseType = responseType;
  }

  @Override
  public Type responseType() {
    return responseType;
  }

  @Override
  public &lt;R&gt; CustomCall&lt;R&gt; adapt(Call&lt;R&gt; call) {
    // 由 CustomCall 决定如何使用
    return new CustomCall&lt;&gt;(call);
  }
}  
</code></pre><p>提供一个CustomCallAdapterFactory用于向Retrofit提供CustomCallAdapter：  </p>
<pre><code>public static class CustomCallAdapterFactory extends CallAdapter.Factory {
  public static final CustomCallAdapterFactory INSTANCE = new CustomCallAdapterFactory();

  @Override
  public CallAdapter&lt;?&gt; get(Type returnType, Annotation[] annotations, Retrofit retrofit) {
    // 获取原始类型
    Class&lt;?&gt; rawType = getRawType(returnType);
    // 返回值必须是CustomCall并且带有泛型
    if (rawType == CustomCall.class &amp;&amp; returnType instanceof ParameterizedType) {
      Type callReturnType = getParameterUpperBound(0, (ParameterizedType) returnType);
      return new CustomCallAdapter(callReturnType);
    }
    return null;
  }
}  
</code></pre><p>使用addCallAdapterFactory向Retrofit注册CustomCallAdapterFactory  </p>
<pre><code>Retrofit retrofit = new Retrofit.Builder()
      .baseUrl(&quot;http://localhost:4567/&quot;)
      .addConverterFactory(Example09.StringConverterFactory.create())
      .addConverterFactory(GsonConverterFactory.create())
      .addCallAdapterFactory(CustomCallAdapterFactory.INSTANCE)
      .build();  
</code></pre><p>注： addCallAdapterFactory与addConverterFactory同理，也有先后顺序。</p>
<p>示例源码见 <a href="https://github.com/ikidou/Retrofit2Demo/blob/master/client/src/main/java/com/github/ikidou/Example10.java" target="_blank" rel="external">Example10.java</a>  </p>
<h2 id="7、其它说明"><a href="#7、其它说明" class="headerlink" title="7、其它说明"></a>7、其它说明</h2><h3 id="7-1-Retrofit-Builder"><a href="#7-1-Retrofit-Builder" class="headerlink" title="7.1 Retrofit.Builder"></a>7.1 Retrofit.Builder</h3><p>前面用到了 Retrofit.Builder 中的baseUrl、addCallAdapterFactory、addConverterFactory、build方法，还有callbackExecutor、callFactory、client、validateEagerly这四个方法没有用到，这里简单的介绍一下。  </p>
<p><img src="http://obbu6r1mi.bkt.clouddn.com/retrofit2/retrofit5.png" alt="">  </p>
<h3 id="7-2-Retrofit的Url组合规则"><a href="#7-2-Retrofit的Url组合规则" class="headerlink" title="7.2 Retrofit的Url组合规则"></a>7.2 Retrofit的Url组合规则</h3><p><img src="http://obbu6r1mi.bkt.clouddn.com/retrofit2/retrofit6.png" alt="">  </p>
<p>从上面不能难看出以下规则：</p>
<ul>
<li>如果你在注解中提供的url是完整的url，则url将作为请求的url。</li>
<li>如果你在注解中提供的url是不完整的url，且不以 / 开头，则请求的url为baseUrl+注解中提供的值</li>
<li>如果你在注解中提供的url是不完整的url，且以 / 开头，则请求的url为baseUrl的主机部分+注解中提供的值  </li>
</ul>
<h3 id="7-3-Retrofit提供的Converter"><a href="#7-3-Retrofit提供的Converter" class="headerlink" title="7.3 Retrofit提供的Converter"></a>7.3 Retrofit提供的Converter</h3><p><img src="http://obbu6r1mi.bkt.clouddn.com/retrofit2/retrofit7.png" alt="">  </p>
<h3 id="7-4-Retrofit提供的CallAdapter："><a href="#7-4-Retrofit提供的CallAdapter：" class="headerlink" title="7.4 Retrofit提供的CallAdapter："></a>7.4 Retrofit提供的CallAdapter：</h3><p><img src="http://obbu6r1mi.bkt.clouddn.com/retrofit2/retrofit8.png" alt="">   </p>
<h3 id="7-5-关于源码"><a href="#7-5-关于源码" class="headerlink" title="7.5 关于源码"></a>7.5 关于源码</h3><p>看到这儿可能有小伙伴要问为什么源码没有把类拆分到单独的文件，命名也不能体现其用途，这里主要是因为方便大家看源码，而不是将注意力放在反复跳转上，另一方面也是因为同一个例子中不可避免的使用其它小节要介绍的内容，所以就直接用了ExampleXX的形式，不过在项目中千万不要使用这种方式，一定要好好命名，做到见名知意。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>其它本博客的内容早就已经完成好了，但由于当时HTTP、反射、注解的博客一篇也没有写，所以一直没有发，期间也有不少的博主写了Retrofit2的博文，不过呢没有自定义相关的内容也没有对各个注解进行详解，所以我还是决定发出来帮助一下那此对Retrofit2无从下手同鞋。</p>
<p>这次Retrofit2的内容就到这里啦，下次再见。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/ocnyang.png"
               alt="OCN.Yang" />
          <p class="site-author-name" itemprop="name">OCN.Yang</p>
           
              <p class="site-description motion-element" itemprop="description">拼凑江山，只为遇见你时自己不那么不堪</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">47</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">9</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">36</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="http://www.jianshu.com/users/e61d05cbf47e/latest_articles" target="_blank" title="简书">
                  
                    <i class="fa fa-fw fa-pencil"></i>
                  
                  简书
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://github.com/ocnyang" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/shedoor" target="_blank" title="Weibo">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  Weibo
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://love.shedoor.net/" target="_blank" title="Meet you">
                  
                    <i class="fa fa-fw fa-heartbeat"></i>
                  
                  Meet you
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              Links
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://www.shedoor.net/" title="个人" target="_blank">个人</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2014 - 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">OCN.Yang</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      本站访客数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      人次
    </span>
  

  
    <span class="site-pv">
      本站总访问量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>


        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"ocnyang"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  
















  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("gh3omnCzhrHskUI74veM8V99-gzGzoHsz", "S5X90d5uKqp25VMacYGLwL60");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  

</body>
</html>
